// Generated by ReScript, PLEASE EDIT WITH CARE

import * as React from "react";
import * as CanvasRenderer from "./CanvasRenderer.res.mjs";
import * as Primitive_option from "rescript/lib/es6/Primitive_option.js";
import * as JsxRuntime from "react/jsx-runtime";

function hoverToNullable(cell) {
  if (cell !== undefined) {
    return [
      cell[0],
      cell[1]
    ];
  } else {
    return null;
  }
}

function CanvasViewport(props) {
  let tileMask = props.tileMask;
  let brushCenterDimJ = props.brushCenterDimJ;
  let brushCenterDimI = props.brushCenterDimI;
  let brush = props.brush;
  let clearHoverRef = props.clearHoverRef;
  let isSilhouette = props.isSilhouette;
  let canvasBackgroundColor = props.canvasBackgroundColor;
  let showCursorOverlay = props.showCursorOverlay;
  let applyBrush = props.applyBrush;
  let isMouseDown = props.isMouseDown;
  let setCursorOverlayOff = props.setCursorOverlayOff;
  let cursorOverlayOff = props.cursorOverlayOff;
  let pan = props.pan;
  let zoom = props.zoom;
  let boardDimJ = props.boardDimJ;
  let boardDimI = props.boardDimI;
  let board = props.board;
  let canvasContainerRef = props.canvasContainerRef;
  let canvasRef = React.useRef(null);
  let rendererRef = React.useRef(undefined);
  let hoveredCellRef = React.useRef(undefined);
  let panY = pan[1];
  let panX = pan[0];
  let withRenderer = callback => {
    let renderer = rendererRef.current;
    if (renderer !== undefined) {
      return callback(Primitive_option.valFromOption(renderer));
    }
    
  };
  React.useEffect(() => {
    let canvasElement = canvasRef.current;
    if (canvasElement == null) {
      return;
    }
    let maybeRenderer = CanvasRenderer.create(canvasElement);
    if (maybeRenderer == null) {
      console.log("Unable to initialize WebGL2 renderer");
      return;
    } else {
      rendererRef.current = Primitive_option.some(maybeRenderer);
      return () => {
        rendererRef.current = undefined;
        CanvasRenderer.dispose(maybeRenderer);
      };
    }
  }, []);
  React.useEffect(() => {
    withRenderer(renderer => {
      CanvasRenderer.setSize(renderer, boardDimJ, boardDimI, 16);
      CanvasRenderer.updateBoard(renderer, board, canvasBackgroundColor, isSilhouette);
      CanvasRenderer.render(renderer);
      CanvasRenderer.setHover(renderer, hoverToNullable(hoveredCellRef.current));
    });
  }, [
    board,
    boardDimI,
    boardDimJ,
    canvasBackgroundColor,
    isSilhouette
  ]);
  React.useEffect(() => {
    withRenderer(renderer => {
      CanvasRenderer.updateBrush(renderer, brush, brushCenterDimI, brushCenterDimJ);
      CanvasRenderer.setHover(renderer, hoverToNullable(hoveredCellRef.current));
    });
  }, [
    brush,
    props.brushDimI,
    props.brushDimJ,
    brushCenterDimI,
    brushCenterDimJ
  ]);
  React.useEffect(() => {
    withRenderer(renderer => {
      CanvasRenderer.updateTileMask(renderer, tileMask);
      CanvasRenderer.setHover(renderer, hoverToNullable(hoveredCellRef.current));
    });
  }, [
    tileMask,
    props.tileMaskDimI,
    props.tileMaskDimJ
  ]);
  React.useEffect(() => {
    withRenderer(renderer => {
      let overlayEnabled = showCursorOverlay && !cursorOverlayOff;
      CanvasRenderer.setOverlayOptions(renderer, overlayEnabled, isSilhouette);
      CanvasRenderer.render(renderer);
    });
  }, [
    showCursorOverlay,
    cursorOverlayOff,
    isSilhouette
  ]);
  let updateHover = hover => {
    hoveredCellRef.current = hover;
    withRenderer(renderer => CanvasRenderer.setHover(renderer, hoverToNullable(hover)));
  };
  React.useEffect(() => {
    clearHoverRef.current = () => updateHover(undefined);
    return () => {
      clearHoverRef.current = () => {};
    };
  }, []);
  let getCellFromEvent = event => {
    let containerElement = canvasContainerRef.current;
    if (containerElement == null) {
      return;
    }
    let rect = containerElement.getBoundingClientRect();
    let clientX = event.clientX;
    let clientY = event.clientY;
    let relativeX = clientX - rect.left;
    let relativeY = clientY - rect.top;
    let boardX = (relativeX - panX) / zoom;
    let boardY = (relativeY - panY) / zoom;
    if (boardX < 0 || boardY < 0) {
      return;
    }
    let col = Math.floor(boardX / 16) | 0;
    let row = Math.floor(boardY / 16) | 0;
    if (col < 0 || col >= boardDimJ || row < 0 || row >= boardDimI) {
      return;
    } else {
      return [
        row,
        col
      ];
    }
  };
  let handleMouseMove = event => {
    setCursorOverlayOff(param => false);
    let match = getCellFromEvent(event);
    if (match === undefined) {
      return updateHover(undefined);
    }
    let col = match[1];
    let row = match[0];
    updateHover([
      row,
      col
    ]);
    if (isMouseDown) {
      return applyBrush(row, col);
    }
    
  };
  let handleMouseDown = event => {
    let match = getCellFromEvent(event);
    if (match === undefined) {
      return;
    }
    let col = match[1];
    let row = match[0];
    updateHover([
      row,
      col
    ]);
    applyBrush(row, col);
    setCursorOverlayOff(param => true);
  };
  let handleMouseLeave = param => updateHover(undefined);
  let canvasWidth = (boardDimJ << 4);
  let canvasHeight = (boardDimI << 4);
  let widthString = canvasWidth.toString() + "px";
  let heightString = canvasHeight.toString() + "px";
  return JsxRuntime.jsx("div", {
    children: JsxRuntime.jsx("div", {
      children: JsxRuntime.jsx("canvas", {
        ref: Primitive_option.some(canvasRef),
        className: "absolute top-0 left-0 block",
        style: {
          height: heightString,
          imageRendering: "pixelated",
          width: widthString
        },
        onMouseDown: handleMouseDown,
        onMouseEnter: handleMouseMove,
        onMouseLeave: handleMouseLeave,
        onMouseMove: handleMouseMove
      }),
      className: "absolute top-0 left-0",
      style: {
        backgroundColor: canvasBackgroundColor,
        transform: props.transformValue,
        transformOrigin: "top left"
      }
    }),
    ref: Primitive_option.some(canvasContainerRef),
    className: "relative border border-gray-300 overflow-hidden w-full h-full",
    style: {
      backgroundColor: props.viewportBackgroundColor
    }
  });
}

let cellSize = 16;

let cellSizeFloat = 16;

let make = CanvasViewport;

export {
  cellSize,
  cellSizeFloat,
  hoverToNullable,
  make,
}
/* react Not a pure module */
