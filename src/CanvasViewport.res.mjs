// Generated by ReScript, PLEASE EDIT WITH CARE

import * as Board from "./Board.res.mjs";
import * as React from "react";
import * as CanvasRenderer from "./CanvasRenderer.res.mjs";
import * as Primitive_option from "rescript/lib/es6/Primitive_option.js";
import * as JsxRuntime from "react/jsx-runtime";

let gridLineThickness = 1 / 16;

function hoverToNullable(cell) {
  if (cell !== undefined) {
    return [
      cell[0],
      cell[1]
    ];
  } else {
    return null;
  }
}

function CanvasViewport(props) {
  let onWheel = props.onWheel;
  let tileMask = props.tileMask;
  let brushCenterDimJ = props.brushCenterDimJ;
  let brushCenterDimI = props.brushCenterDimI;
  let brush = props.brush;
  let clearHoverRef = props.clearHoverRef;
  let isSilhouette = props.isSilhouette;
  let checkeredSecondaryColor = props.checkeredSecondaryColor;
  let checkeredPrimaryColor = props.checkeredPrimaryColor;
  let gridLineColor = props.gridLineColor;
  let canvasBackgroundColor = props.canvasBackgroundColor;
  let gridMode = props.gridMode;
  let overlayColor = props.overlayColor;
  let overlayMode = props.overlayMode;
  let showCursorOverlay = props.showCursorOverlay;
  let isPickingColor = props.isPickingColor;
  let setHoveredPickColor = props.setHoveredPickColor;
  let handlePickColor = props.handlePickColor;
  let applyBrush = props.applyBrush;
  let isMouseDown = props.isMouseDown;
  let setCursorOverlayOff = props.setCursorOverlayOff;
  let cursorOverlayOff = props.cursorOverlayOff;
  let pan = props.pan;
  let zoom = props.zoom;
  let boardDimJ = props.boardDimJ;
  let boardDimI = props.boardDimI;
  let board = props.board;
  let canvasContainerRef = props.canvasContainerRef;
  let canvasRef = React.useRef(null);
  let rendererRef = React.useRef(undefined);
  let hoveredCellRef = React.useRef(undefined);
  let panY = pan[1];
  let panX = pan[0];
  let withRenderer = callback => {
    let renderer = rendererRef.current;
    if (renderer !== undefined) {
      return callback(Primitive_option.valFromOption(renderer));
    }
    
  };
  React.useEffect(() => {
    let canvasElement = canvasRef.current;
    if (canvasElement == null) {
      return;
    }
    let maybeRenderer = CanvasRenderer.create(canvasElement);
    if (maybeRenderer == null) {
      console.log("Unable to initialize WebGL2 renderer");
      return;
    } else {
      rendererRef.current = Primitive_option.some(maybeRenderer);
      return () => {
        rendererRef.current = undefined;
        CanvasRenderer.dispose(maybeRenderer);
      };
    }
  }, []);
  React.useEffect(() => {
    withRenderer(renderer => {
      CanvasRenderer.setSize(renderer, boardDimJ, boardDimI, 1);
      CanvasRenderer.updateBoard(renderer, board, canvasBackgroundColor, isSilhouette);
      CanvasRenderer.render(renderer);
      CanvasRenderer.setHover(renderer, hoverToNullable(hoveredCellRef.current));
    });
  }, [
    board,
    boardDimI,
    boardDimJ,
    canvasBackgroundColor,
    isSilhouette
  ]);
  React.useEffect(() => {
    withRenderer(renderer => {
      CanvasRenderer.updateBrush(renderer, brush, brushCenterDimI, brushCenterDimJ);
      CanvasRenderer.setHover(renderer, hoverToNullable(hoveredCellRef.current));
    });
  }, [
    brush,
    props.brushDimI,
    props.brushDimJ,
    brushCenterDimI,
    brushCenterDimJ
  ]);
  React.useEffect(() => {
    withRenderer(renderer => {
      CanvasRenderer.updateTileMask(renderer, tileMask);
      CanvasRenderer.setHover(renderer, hoverToNullable(hoveredCellRef.current));
    });
  }, [
    tileMask,
    props.tileMaskDimI,
    props.tileMaskDimJ
  ]);
  React.useEffect(() => {
    withRenderer(renderer => {
      let overlayEnabled = showCursorOverlay && !cursorOverlayOff;
      CanvasRenderer.setOverlayOptions(renderer, overlayEnabled, isSilhouette, overlayMode, overlayColor);
      CanvasRenderer.render(renderer);
    });
  }, [
    showCursorOverlay,
    cursorOverlayOff,
    isSilhouette,
    overlayMode,
    overlayColor
  ]);
  let updateHover = hover => {
    hoveredCellRef.current = hover;
    withRenderer(renderer => CanvasRenderer.setHover(renderer, hoverToNullable(hover)));
  };
  React.useEffect(() => {
    clearHoverRef.current = () => updateHover(undefined);
    return () => {
      clearHoverRef.current = () => {};
    };
  }, []);
  let getCellFromEvent = event => {
    let containerElement = canvasContainerRef.current;
    if (containerElement == null) {
      return;
    }
    let rect = containerElement.getBoundingClientRect();
    let clientX = event.clientX;
    let clientY = event.clientY;
    let relativeX = clientX - rect.left;
    let relativeY = clientY - rect.top;
    let boardX = (relativeX - panX) / zoom;
    let boardY = (relativeY - panY) / zoom;
    let col = Math.floor(boardX / 1) | 0;
    let row = Math.floor(boardY / 1) | 0;
    return [
      row,
      col
    ];
  };
  let isWithinBoard = (row, col) => {
    if (row >= 0 && row < boardDimI && col >= 0) {
      return col < boardDimJ;
    } else {
      return false;
    }
  };
  let handleMouseMove = event => {
    setCursorOverlayOff(param => false);
    let match = getCellFromEvent(event);
    if (match !== undefined) {
      let col = match[1];
      let row = match[0];
      updateHover([
        row,
        col
      ]);
      if (isPickingColor) {
        if (isWithinBoard(row, col)) {
          let hoveredColor = Board.get(board, row, col);
          let hoveredColor$1 = (hoveredColor == null) ? undefined : Primitive_option.some(hoveredColor);
          setHoveredPickColor(param => hoveredColor$1);
        } else {
          setHoveredPickColor(param => {});
        }
      }
      if (isMouseDown && !isPickingColor) {
        return applyBrush(row, col);
      } else {
        return;
      }
    }
    updateHover(undefined);
    if (isPickingColor) {
      return setHoveredPickColor(param => {});
    }
    
  };
  let handleMouseDown = event => {
    let match = getCellFromEvent(event);
    if (match === undefined) {
      return;
    }
    let col = match[1];
    let row = match[0];
    updateHover([
      row,
      col
    ]);
    if (isPickingColor) {
      if (isWithinBoard(row, col)) {
        return handlePickColor(row, col);
      } else {
        return;
      }
    } else {
      applyBrush(row, col);
      return setCursorOverlayOff(param => true);
    }
  };
  let handleMouseLeave = param => {
    updateHover(undefined);
    if (isPickingColor) {
      return setHoveredPickColor(param => {});
    }
    
  };
  let canvasWidth = (boardDimJ << 0);
  let canvasHeight = (boardDimI << 0);
  let widthString = canvasWidth.toString() + "px";
  let heightString = canvasHeight.toString() + "px";
  let cellSizeString = (1).toString() + "px";
  let lineBreadthFull = gridLineThickness / 1;
  let lineBreadth = (lineBreadthFull / 2).toString();
  let lineLength1 = (1 - lineBreadthFull / 2).toString();
  let lineLength2 = (1 - lineBreadthFull).toString();
  let gridSvg = "<svg xmlns='http://www.w3.org/2000/svg' width='1' height='1' viewBox='0 0 1 1' shape-rendering='crispEdges'>" + ("<rect x='0' y='0' width='" + lineBreadth + "' height='1' fill='" + gridLineColor + "'/>") + ("<rect x='" + lineBreadth + "' y='0' width='" + lineLength1 + "' height='" + lineBreadth + "' fill='" + gridLineColor + "'/>") + ("<rect x='" + lineBreadth + "' y='" + lineLength1 + "' width='" + lineLength1 + "' height='" + lineBreadth + "' fill='" + gridLineColor + "'/>") + ("<rect x='" + lineLength1 + "' y='" + lineBreadth + "' width='" + lineBreadth + "' height='" + lineLength2 + "' fill='" + gridLineColor + "'/>") + "</svg>";
  let gridBackgroundImage = "url(\"data:image/svg+xml," + encodeURIComponent(gridSvg) + "\")";
  let gridBackgroundSize = cellSizeString + " " + cellSizeString;
  let doubleCellSizeString = (2).toString() + "px";
  let checkeredSvg = "<svg xmlns='http://www.w3.org/2000/svg' width='2' height='2' shape-rendering='crispEdges'><rect width='1' height='1' fill='" + checkeredPrimaryColor + "'/><rect x='1' y='1' width='1' height='1' fill='" + checkeredPrimaryColor + "'/><rect x='1' width='1' height='1' fill='" + checkeredSecondaryColor + "'/><rect y='1' width='1' height='1' fill='" + checkeredSecondaryColor + "'/></svg>";
  let checkeredBackgroundImage = "url(\"data:image/svg+xml," + encodeURIComponent(checkeredSvg) + "\")";
  let checkeredBackgroundSize = doubleCellSizeString + " " + doubleCellSizeString;
  let dotMaskImage = "url(\"data:image/svg+xml," + encodeURIComponent("<svg xmlns='http://www.w3.org/2000/svg' width='1' height='1' shape-rendering='crispEdges'>\n    <defs>\n      <mask id='hole'>\n        <rect width='1' height='1' fill='white'/>\n        <circle cx='0.5' cy='0.5' r='0.5' fill='black'/>\n      </mask>\n    </defs>\n    <rect width='1' height='1' fill='white' mask='url(#hole)'/>\n  </svg>") + "\")";
  let isGridLinesOverlay = gridMode === "gridOverlay";
  let isGridLinesUnderlay = gridMode === "gridUnderlay";
  let isCheckeredOverlay = gridMode === "checkeredOverlay";
  let isCheckeredUnderlay = gridMode === "checkeredUnderlay";
  return JsxRuntime.jsx("div", {
    children: JsxRuntime.jsxs("div", {
      children: [
        JsxRuntime.jsx("div", {
          className: "absolute top-0 left-0 pointer-events-none",
          style: {
            backgroundColor: canvasBackgroundColor,
            height: heightString,
            width: widthString
          }
        }),
        isCheckeredUnderlay ? JsxRuntime.jsx("div", {
            className: "absolute top-0 left-0 pointer-events-none",
            style: {
              backgroundColor: checkeredSecondaryColor,
              backgroundImage: checkeredBackgroundImage,
              backgroundSize: checkeredBackgroundSize,
              height: heightString,
              imageRendering: "pixelated",
              width: widthString
            }
          }) : null,
        isGridLinesUnderlay ? JsxRuntime.jsx("div", {
            className: "absolute top-0 left-0 pointer-events-none",
            style: {
              backgroundImage: gridBackgroundImage,
              backgroundSize: gridBackgroundSize,
              height: heightString,
              width: widthString
            }
          }) : null,
        JsxRuntime.jsx("canvas", {
          ref: Primitive_option.some(canvasRef),
          className: "absolute top-0 left-0 block",
          style: {
            height: heightString,
            imageRendering: "pixelated",
            width: widthString
          }
        }),
        props.isDotMask ? JsxRuntime.jsx("div", {
            className: "absolute top-0 left-0 pointer-events-none",
            style: {
              backgroundColor: canvasBackgroundColor,
              backgroundSize: gridBackgroundSize,
              height: heightString,
              maskImage: dotMaskImage,
              maskSize: gridBackgroundSize,
              width: widthString
            }
          }) : null,
        isGridLinesOverlay ? JsxRuntime.jsx("div", {
            className: "absolute top-0 left-0 pointer-events-none",
            style: {
              backgroundImage: gridBackgroundImage,
              backgroundSize: gridBackgroundSize,
              height: heightString,
              width: widthString
            }
          }) : null,
        isCheckeredOverlay ? JsxRuntime.jsx("div", {
            className: "absolute top-0 left-0 pointer-events-none",
            style: {
              backgroundColor: checkeredSecondaryColor,
              backgroundImage: checkeredBackgroundImage,
              backgroundSize: checkeredBackgroundSize,
              height: heightString,
              imageRendering: "pixelated",
              width: widthString
            }
          }) : null
      ],
      className: "absolute top-0 left-0",
      style: {
        transform: props.transformValue,
        transformOrigin: "top left"
      }
    }),
    ref: Primitive_option.some(canvasContainerRef),
    className: "relative border border-[color:var(--plain-300)] overflow-hidden w-full h-full",
    style: {
      backgroundColor: props.viewportBackgroundColor
    },
    onMouseDown: handleMouseDown,
    onMouseEnter: handleMouseMove,
    onMouseLeave: handleMouseLeave,
    onMouseMove: handleMouseMove,
    onWheel: event => {
      event.preventDefault();
      onWheel(event);
    }
  });
}

let cellSize = 1;

let cellSizeFloat = 1;

let baseGridCellSize = 16;

let make = CanvasViewport;

export {
  cellSize,
  cellSizeFloat,
  baseGridCellSize,
  gridLineThickness,
  hoverToNullable,
  make,
}
/* Board Not a pure module */
