// Generated by ReScript, PLEASE EDIT WITH CARE

import * as Board from "./Board.res.mjs";
import * as React from "react";
import * as Array2D from "./Array2D.res.mjs";
import * as Initials from "./Initials.res.mjs";
import * as Belt_Array from "rescript/lib/es6/Belt_Array.js";
import * as Belt_Float from "rescript/lib/es6/Belt_Float.js";
import * as ColorsUsed from "./ColorsUsed.res.mjs";
import * as Stdlib_Int from "rescript/lib/es6/Stdlib_Int.js";
import * as ZoomControl from "./ZoomControl.res.mjs";
import * as Color from "@texel/color";
import * as ColorControl from "./ColorControl.res.mjs";
import * as ExportControl from "./ExportControl.res.mjs";
import * as Primitive_int from "rescript/lib/es6/Primitive_int.js";
import * as Stdlib_Option from "rescript/lib/es6/Stdlib_Option.js";
import * as CanvasViewport from "./CanvasViewport.res.mjs";
import * as DotModeControl from "./DotModeControl.res.mjs";
import * as ExportBoardJs from "./exportBoard.js";
import * as CanvasThumbnails from "./CanvasThumbnails.res.mjs";
import * as CanvasGridControl from "./CanvasGridControl.res.mjs";
import * as CanvasSizeControl from "./CanvasSizeControl.res.mjs";
import * as SavedBrushesPanel from "./SavedBrushesPanel.res.mjs";
import * as SilhouetteControl from "./SilhouetteControl.res.mjs";
import * as JsxRuntime from "react/jsx-runtime";
import * as BrushOverlayControl from "./BrushOverlayControl.res.mjs";
import * as CanvasColorsControl from "./CanvasColorsControl.res.mjs";
import * as SavedTileMasksPanel from "./SavedTileMasksPanel.res.mjs";
import UseLocalStorageJs from "./useLocalStorage.js";
import * as UseLocalStorageJs$1 from "./useLocalStorage.js";

function generateCanvasId() {
  let timestamp = Date.now().toString();
  let random = Math.random().toString();
  return timestamp + "-" + random;
}

function makeCanvas(zoom, pan, isDotMaskOpt, canvasBackgroundColorOpt) {
  let isDotMask = isDotMaskOpt !== undefined ? isDotMaskOpt : false;
  let canvasBackgroundColor = canvasBackgroundColorOpt !== undefined ? canvasBackgroundColorOpt : Initials.canvasBackgroundColor;
  return {
    id: generateCanvasId(),
    zoom: zoom,
    pan: pan,
    isDotMask: isDotMask,
    canvasBackgroundColor: canvasBackgroundColor
  };
}

function useIsMouseDown() {
  let match = React.useState(() => false);
  let setIsMouseDown = match[1];
  React.useEffect(() => {
    let downHandler = param => {
      setIsMouseDown(param => true);
      UseLocalStorageJs$1.setLocalStoragePersistencePaused(true);
    };
    let upHandler = param => {
      setIsMouseDown(param => false);
      UseLocalStorageJs$1.setLocalStoragePersistencePaused(false);
    };
    window.addEventListener("mousedown", downHandler);
    window.addEventListener("mouseup", upHandler);
    return () => {
      window.removeEventListener("mousedown", downHandler);
      window.removeEventListener("mouseup", upHandler);
      UseLocalStorageJs$1.setLocalStoragePersistencePaused(false);
    };
  }, []);
  return match[0];
}

function _isLight(color) {
  let match = Color.convert(Color.hexToRGB(color), Color.sRGB, Color.OKHSL);
  return match[2] > 0.5;
}

let defaultTileMasks = [
  [[true]],
  [
    [
      true,
      false
    ],
    [
      false,
      true
    ]
  ],
  [
    [
      false,
      true
    ],
    [
      true,
      false
    ]
  ],
  [
    [
      false,
      true
    ],
    [
      false,
      true
    ]
  ],
  [
    [
      true,
      false
    ],
    [
      true,
      false
    ]
  ],
  [
    [
      false,
      false
    ],
    [
      true,
      true
    ]
  ],
  [
    [
      true,
      true
    ],
    [
      false,
      false
    ]
  ],
  [
    [
      true,
      false,
      false
    ],
    [
      false,
      true,
      false
    ],
    [
      false,
      false,
      true
    ]
  ]
];

let defaultBrushes = [
  Array2D.make(1, 1, () => true),
  Array2D.make(2, 2, () => true),
  Array2D.make(3, 3, () => true),
  Array2D.make(4, 4, () => true),
  Array2D.make(8, 8, () => true),
  Array2D.make(12, 12, () => true),
  Array2D.make(16, 16, () => true)
];

function App(props) {
  let canvasContainerRef = React.useRef(null);
  let match = React.useState(() => [
    192,
    192
  ]);
  let setViewportCenter = match[1];
  let viewportCenter = match[0];
  let viewportCenterRef = React.useRef(viewportCenter);
  viewportCenterRef.current = viewportCenter;
  let updateViewportCenter = () => {
    let element = canvasContainerRef.current;
    if (element == null) {
      return;
    }
    let rect = element.getBoundingClientRect();
    let nextCenter_0 = rect.width / 2;
    let nextCenter_1 = rect.height / 2;
    let nextCenter = [
      nextCenter_0,
      nextCenter_1
    ];
    viewportCenterRef.current = nextCenter;
    setViewportCenter(param => nextCenter);
  };
  React.useEffect(() => {
    updateViewportCenter();
    let handleResize = param => updateViewportCenter();
    window.addEventListener("resize", handleResize);
    return () => {
      window.removeEventListener("resize", handleResize);
    };
  }, []);
  let clampZoom = value => {
    let cappedMax = value > Initials.maxZoomIn ? Initials.maxZoomIn : value;
    if (cappedMax < Initials.maxZoomOut) {
      return Initials.maxZoomOut;
    } else {
      return cappedMax;
    }
  };
  let computeCenteredPan = (dimI, dimJ, zoomValue) => {
    let match = viewportCenterRef.current;
    let boardWidth = dimJ * 1;
    let boardHeight = dimI * 1;
    let nextPanX = match[0] - boardWidth * zoomValue / 2;
    let nextPanY = match[1] - boardHeight * zoomValue / 2;
    return [
      nextPanX,
      nextPanY
    ];
  };
  let computeZoomToFitForDimensions = (dimI, dimJ) => {
    let containerElement = canvasContainerRef.current;
    if (containerElement == null) {
      return;
    }
    let rect = containerElement.getBoundingClientRect();
    let viewportWidth = rect.width;
    let viewportHeight = rect.height;
    let boardWidth = dimJ * 1;
    let boardHeight = dimI * 1;
    if (viewportWidth <= 0 || viewportHeight <= 0 || boardWidth <= 0 || boardHeight <= 0) {
      return;
    }
    let zoomByWidth = viewportWidth / boardWidth;
    let zoomByHeight = viewportHeight / boardHeight;
    let zoomToFit = zoomByWidth < zoomByHeight ? zoomByWidth : zoomByHeight;
    return clampZoom(zoomToFit);
  };
  let computeFitViewForDimensions = (dimI, dimJ) => {
    let fallbackPan = computeCenteredPan(dimI, dimJ, 1);
    let nextZoom = computeZoomToFitForDimensions(dimI, dimJ);
    if (nextZoom === undefined) {
      return [
        1,
        fallbackPan
      ];
    }
    let nextPan = computeCenteredPan(dimI, dimJ, nextZoom);
    return [
      nextZoom,
      nextPan
    ];
  };
  let makeDefaultCanvas = () => {
    let defaultBoard = Board.make(12, 12);
    let match = computeFitViewForDimensions(12, 12);
    return [
      makeCanvas(match[0], match[1], false, undefined),
      defaultBoard
    ];
  };
  let match$1 = UseLocalStorageJs("brush-mode", "Color");
  let setBrushMode = match$1[1];
  let brushMode = match$1[0];
  let match$2 = UseLocalStorageJs("canvas-metadata-v1", []);
  let setCanvases = match$2[1];
  let canvases = match$2[0];
  let match$3 = UseLocalStorageJs("canvas-boards-v1", []);
  let setCanvasBoards = match$3[1];
  let canvasBoards = match$3[0];
  let match$4 = UseLocalStorageJs("selected-canvas-id", "");
  let setSelectedCanvasId = match$4[1];
  let selectedCanvasId = match$4[0];
  let match$5 = UseLocalStorageJs("brush", Array2D.make(3, 3, () => true));
  let setBrush = match$5[1];
  let brush = match$5[0];
  let match$6 = UseLocalStorageJs("saved-brushes", defaultBrushes);
  let setSavedBrushes = match$6[1];
  let savedBrushes = match$6[0];
  let match$7 = UseLocalStorageJs("saved-tile-masks", defaultTileMasks);
  let setSavedTileMasks = match$7[1];
  let savedTileMasks = match$7[0];
  let match$8 = UseLocalStorageJs("selected-tile-mask-index", 0);
  let setSelectedTileMaskIndex = match$8[1];
  let selectedTileMaskIndex = match$8[0];
  let match$9 = UseLocalStorageJs("tile-mask", Array2D.make(4, 4, () => true));
  let setTileMask = match$9[1];
  let tileMask = match$9[0];
  let match$10 = UseLocalStorageJs("brush-overlay-mode", "overlay");
  let overlayMode = match$10[0];
  let showCursorOverlay;
  switch (overlayMode) {
    case "none" :
      showCursorOverlay = false;
      break;
    case "overlay" :
    case "color" :
      showCursorOverlay = true;
      break;
  }
  let match$11 = UseLocalStorageJs("grid-mode", "none");
  let gridMode = match$11[0];
  let match$12 = UseLocalStorageJs("my-color", Initials.myColor);
  let setMyColor = match$12[1];
  let myColor = match$12[0];
  let match$13 = UseLocalStorageJs("canvas-silhouette", false);
  let isSilhouette = match$13[0];
  let match$14 = UseLocalStorageJs("viewport-background-color", Initials.viewportBackgroundColor);
  let viewportBackgroundColor = match$14[0];
  let match$15 = React.useState(() => false);
  let setCursorOverlayOff = match$15[1];
  let match$16 = React.useState(() => "16");
  let exportScaleInput = match$16[0];
  let match$17 = React.useState(() => true);
  let includeExportBackground = match$17[0];
  let match$18 = React.useState(() => "Scale");
  let resizeMode = match$18[0];
  let match$19 = React.useState(() => false);
  let setIsPickingColor = match$19[1];
  let isPickingColor = match$19[0];
  let match$20 = React.useState(() => {});
  let setHoveredPickColor = match$20[1];
  let clearHoverRef = React.useRef(() => {});
  let zoomRef = React.useRef(1);
  let panRef = React.useRef([
    0,
    0
  ]);
  let isMouseDown = useIsMouseDown();
  let onStartColorPick = () => setIsPickingColor(prev => {
    let next = !prev;
    setHoveredPickColor(param => {});
    if (next) {
      clearHoverRef.current();
      setCursorOverlayOff(param => false);
    }
    return next;
  });
  let canvasCount = canvases.length;
  React.useEffect(() => {
    if (canvasCount === 0) {
      updateViewportCenter();
      let match = makeDefaultCanvas();
      let defaultBoard = match[1];
      let defaultCanvas = match[0];
      setCanvases(param => [defaultCanvas]);
      setCanvasBoards(param => [{
          id: defaultCanvas.id,
          board: defaultBoard
        }]);
      setSelectedCanvasId(param => defaultCanvas.id);
    }
    
  }, []);
  let canvas = Belt_Array.getBy(canvases, canvas => canvas.id === selectedCanvasId);
  let currentCanvas;
  if (canvas !== undefined) {
    currentCanvas = canvas;
  } else {
    let firstCanvas = canvases[0];
    currentCanvas = firstCanvas !== undefined ? firstCanvas : makeDefaultCanvas()[0];
  }
  let currentCanvasId = currentCanvas.id;
  let match$21 = React.useState(() => currentCanvas.isDotMask);
  let setIncludeExportDotMask = match$21[1];
  let includeExportDotMask = match$21[0];
  React.useEffect(() => {
    setIncludeExportDotMask(prev => {
      if (prev === currentCanvas.isDotMask) {
        return prev;
      } else {
        return currentCanvas.isDotMask;
      }
    });
  }, [currentCanvasId]);
  let currentCanvasIdRef = React.useRef(currentCanvasId);
  currentCanvasIdRef.current = currentCanvasId;
  React.useEffect(() => {
    let hasValidSelection = Belt_Array.some(canvases, canvas => canvas.id === selectedCanvasId);
    if (!hasValidSelection) {
      let firstCanvas = canvases[0];
      if (firstCanvas !== undefined && firstCanvas.id !== selectedCanvasId) {
        setSelectedCanvasId(param => firstCanvas.id);
      }
      
    }
    
  }, [
    canvases,
    selectedCanvasId
  ]);
  let entry = Belt_Array.getBy(canvasBoards, entry => entry.id === currentCanvasId);
  let board = entry !== undefined ? entry.board : Board.make(12, 12);
  let zoom = currentCanvas.zoom;
  let pan = currentCanvas.pan;
  let isDotMask = currentCanvas.isDotMask;
  let canvasBackgroundColor = currentCanvas.canvasBackgroundColor;
  let isCanvasBackgroundLight = _isLight(canvasBackgroundColor);
  let gridLineColor = isCanvasBackgroundLight ? "rgba(0, 0, 0, 0.25)" : "rgba(255, 255, 255, 0.25)";
  let checkeredPrimaryColor = isCanvasBackgroundLight ? "rgba(0, 0, 0, 0.15)" : "rgba(255, 255, 255, 0.15)";
  let checkeredSecondaryColor = isCanvasBackgroundLight ? "rgba(0, 0, 0, 0.00)" : "rgba(255, 255, 255, 0.00)";
  zoomRef.current = zoom;
  panRef.current = pan;
  let handlePickColor = (row, col) => {
    let pickedColor = Board.get(board, row, col);
    if (!(pickedColor == null)) {
      setMyColor(param => pickedColor);
      setBrushMode(param => "Color");
    }
    setIsPickingColor(param => false);
    setHoveredPickColor(param => {});
  };
  let updateCanvasById = (targetId, updater) => setCanvases(prev => prev.map(canvas => {
    if (canvas.id === targetId) {
      return updater(canvas);
    } else {
      return canvas;
    }
  }));
  let updateCanvasBoardById = (targetId, updater) => setCanvasBoards(prev => {
    let updatedRef = {
      contents: false
    };
    let mapped = prev.map(entry => {
      if (entry.id === targetId) {
        updatedRef.contents = true;
        return {
          id: entry.id,
          board: updater(entry.board)
        };
      } else {
        return entry;
      }
    });
    if (updatedRef.contents) {
      return mapped;
    } else {
      return mapped.concat([{
          id: targetId,
          board: updater(Board.make(12, 12))
        }]);
    }
  });
  let setCanvasDotMask = updater => updateCanvasById(currentCanvasIdRef.current, canvas => ({
    id: canvas.id,
    zoom: canvas.zoom,
    pan: canvas.pan,
    isDotMask: updater(canvas.isDotMask),
    canvasBackgroundColor: canvas.canvasBackgroundColor
  }));
  let setCanvasBackgroundColor = updater => updateCanvasById(currentCanvasIdRef.current, canvas => ({
    id: canvas.id,
    zoom: canvas.zoom,
    pan: canvas.pan,
    isDotMask: canvas.isDotMask,
    canvasBackgroundColor: updater(canvas.canvasBackgroundColor)
  }));
  let updatePan = updater => updateCanvasById(currentCanvasIdRef.current, canvas => {
    let nextPan = updater(canvas.pan);
    panRef.current = nextPan;
    return {
      id: canvas.id,
      zoom: canvas.zoom,
      pan: nextPan,
      isDotMask: canvas.isDotMask,
      canvasBackgroundColor: canvas.canvasBackgroundColor
    };
  });
  let adjustPan = (deltaX, deltaY) => updatePan(param => [
    param[0] + deltaX,
    param[1] + deltaY
  ]);
  let updateZoom = updater => updateCanvasById(currentCanvasIdRef.current, canvas => {
    let prevZoom = canvas.zoom;
    let nextZoom = clampZoom(updater(prevZoom));
    if (nextZoom !== prevZoom) {
      let match = viewportCenterRef.current;
      let centerY = match[1];
      let centerX = match[0];
      let match$1 = canvas.pan;
      let boardCenterX = (centerX - match$1[0]) / prevZoom;
      let boardCenterY = (centerY - match$1[1]) / prevZoom;
      let nextPanX = centerX - boardCenterX * nextZoom;
      let nextPanY = centerY - boardCenterY * nextZoom;
      let nextPan = [
        nextPanX,
        nextPanY
      ];
      zoomRef.current = nextZoom;
      panRef.current = nextPan;
      return {
        id: canvas.id,
        zoom: nextZoom,
        pan: nextPan,
        isDotMask: canvas.isDotMask,
        canvasBackgroundColor: canvas.canvasBackgroundColor
      };
    }
    zoomRef.current = nextZoom;
    return canvas;
  });
  let zoomIn = () => updateZoom(prev => prev * Initials.zoom_factor);
  let zoomOut = () => {
    let factor = 1 / Initials.zoom_factor;
    updateZoom(prev => prev * factor);
  };
  let match$22 = Board.dims(board);
  let boardDimJ = match$22[1];
  let boardDimI = match$22[0];
  let fitZoom = computeZoomToFitForDimensions(boardDimI, boardDimJ);
  let zoomPercent = fitZoom !== undefined ? (
      fitZoom <= 0 ? zoom * 100 : zoom / fitZoom * 100
    ) : zoom * 100;
  let lastAutoCenteredDimsRef = React.useRef(undefined);
  let match$23 = Array2D.dims(brush);
  let brushDimJ = match$23[1];
  let brushDimI = match$23[0];
  let brushCenterDimI = brushDimI / 2 | 0;
  let brushCenterDimJ = brushDimJ / 2 | 0;
  let match$24 = Array2D.dims(tileMask);
  let tileMaskDimJ = match$24[1];
  let tileMaskDimI = match$24[0];
  let centerCanvasForDimensions = (dimI, dimJ) => {
    let match = computeCenteredPan(dimI, dimJ, zoomRef.current);
    let nextPanY = match[1];
    let nextPanX = match[0];
    updatePan(param => {
      let prevY = param[1];
      let prevX = param[0];
      if (prevX === nextPanX && prevY === nextPanY) {
        return [
          prevX,
          prevY
        ];
      } else {
        return [
          nextPanX,
          nextPanY
        ];
      }
    });
  };
  let centerCanvas = () => centerCanvasForDimensions(boardDimI, boardDimJ);
  let fitCanvasToViewportForDimensions = (dimI, dimJ) => {
    let nextZoom = computeZoomToFitForDimensions(dimI, dimJ);
    if (nextZoom !== undefined) {
      return updateCanvasById(currentCanvasIdRef.current, canvas => {
        let match = computeCenteredPan(dimI, dimJ, nextZoom);
        let nextPanY = match[1];
        let nextPanX = match[0];
        zoomRef.current = nextZoom;
        panRef.current = [
          nextPanX,
          nextPanY
        ];
        return {
          id: canvas.id,
          zoom: nextZoom,
          pan: [
            nextPanX,
            nextPanY
          ],
          isDotMask: canvas.isDotMask,
          canvasBackgroundColor: canvas.canvasBackgroundColor
        };
      });
    } else {
      return centerCanvasForDimensions(dimI, dimJ);
    }
  };
  let fitCanvasToViewport = () => fitCanvasToViewportForDimensions(boardDimI, boardDimJ);
  let match$25 = React.useState(() => boardDimI.toString());
  let setResizeRowsInput = match$25[1];
  let resizeRowsInput = match$25[0];
  let match$26 = React.useState(() => boardDimJ.toString());
  let setResizeColsInput = match$26[1];
  let resizeColsInput = match$26[0];
  React.useEffect(() => {
    setResizeRowsInput(param => boardDimI.toString());
    setResizeColsInput(param => boardDimJ.toString());
  }, [
    boardDimI,
    boardDimJ
  ]);
  React.useEffect(() => {
    let match = panRef.current;
    let hasCustomPan = match[0] !== 0 || match[1] !== 0;
    let match$1 = lastAutoCenteredDimsRef.current;
    if (match$1 !== undefined) {
      if (match$1[0] !== boardDimI || match$1[1] !== boardDimJ) {
        centerCanvasForDimensions(boardDimI, boardDimJ);
        lastAutoCenteredDimsRef.current = [
          boardDimI,
          boardDimJ
        ];
      }
      
    } else {
      if (!hasCustomPan) {
        centerCanvasForDimensions(boardDimI, boardDimJ);
      }
      lastAutoCenteredDimsRef.current = [
        boardDimI,
        boardDimJ
      ];
    }
  }, [
    boardDimI,
    boardDimJ,
    viewportCenter
  ]);
  React.useEffect(() => {
    let mask = savedTileMasks[selectedTileMaskIndex];
    if (mask !== undefined) {
      if (!Array2D.isEqual(mask, tileMask)) {
        setTileMask(param => mask);
      }
      return;
    }
    if (savedTileMasks.length > 0) {
      let fallbackIndex = selectedTileMaskIndex >= savedTileMasks.length ? savedTileMasks.length - 1 | 0 : 0;
      setSelectedTileMaskIndex(param => fallbackIndex);
    }
    
  }, [
    savedTileMasks,
    selectedTileMaskIndex
  ]);
  let parsePositiveInt = value => {
    let parsed = Stdlib_Int.fromString(value, undefined);
    if (parsed !== undefined && parsed > 0) {
      return parsed;
    }
    
  };
  let parsePositiveFloat = value => {
    let parsed = Belt_Float.fromString(value);
    if (parsed !== undefined && parsed > 0) {
      return parsed;
    }
    
  };
  let mapIndex = (srcSize, dstSize, index) => {
    if (srcSize <= 1 || dstSize <= 1) {
      return 0;
    }
    let numerator = (index * (srcSize - 1 | 0) | 0) + ((dstSize - 1 | 0) / 2 | 0) | 0;
    let denominator = dstSize - 1 | 0;
    let mapped = Primitive_int.div(numerator, denominator);
    let maxIndex = srcSize - 1 | 0;
    if (mapped < 0) {
      return 0;
    } else if (mapped > maxIndex) {
      return maxIndex;
    } else {
      return mapped;
    }
  };
  let match$27 = parsePositiveInt(resizeRowsInput);
  let match$28 = parsePositiveInt(resizeColsInput);
  let canSubmitResize = match$27 !== undefined && match$28 !== undefined ? match$27 !== boardDimI || match$28 !== boardDimJ : false;
  let exportScaleValue = parsePositiveFloat(exportScaleInput);
  let canExport = Stdlib_Option.isSome(exportScaleValue);
  let handleResizeSubmit = () => {
    let match = parsePositiveInt(resizeRowsInput);
    let match$1 = parsePositiveInt(resizeColsInput);
    if (match === undefined) {
      return;
    }
    if (match$1 === undefined) {
      return;
    }
    if (resizeMode === "Scale") {
      updateCanvasBoardById(currentCanvasIdRef.current, prev => {
        let match$2 = Board.dims(prev);
        let prevCols = match$2[1];
        let prevRows = match$2[0];
        let nextBoard = Board.make(match, match$1);
        if (prevRows === 0 || prevCols === 0) {
          return nextBoard;
        }
        for (let rowI = 0; rowI < match; ++rowI) {
          let srcRow = mapIndex(prevRows, match, rowI);
          for (let colJ = 0; colJ < match$1; ++colJ) {
            let srcCol = mapIndex(prevCols, match$1, colJ);
            Board.setInPlace(nextBoard, rowI, colJ, Board.get(prev, srcRow, srcCol));
          }
        }
        return nextBoard;
      });
    } else {
      updateCanvasBoardById(currentCanvasIdRef.current, prev => {
        let nextBoard = Board.make(match, match$1);
        for (let rowI = 0; rowI < match; ++rowI) {
          for (let colJ = 0; colJ < match$1; ++colJ) {
            Board.setInPlace(nextBoard, rowI, colJ, Board.get(prev, rowI, colJ));
          }
        }
        return nextBoard;
      });
    }
    fitCanvasToViewportForDimensions(match, match$1);
    clearHoverRef.current();
    setCursorOverlayOff(param => true);
  };
  let handleExportPng = () => {
    if (exportScaleValue !== undefined) {
      let prim2 = {
        includeBackground: includeExportBackground,
        backgroundColor: canvasBackgroundColor,
        includeDotMask: includeExportDotMask,
        dotMaskColor: canvasBackgroundColor
      };
      ExportBoardJs.exportBoardAsPng(board, exportScaleValue, prim2);
      return;
    }
    
  };
  let selectedSavedBrushIndex = Belt_Array.getIndexBy(savedBrushes, savedBrush => Array2D.isEqual(savedBrush, brush));
  let canDeleteSelectedBrush = Stdlib_Option.isSome(selectedSavedBrushIndex);
  let canDeleteSelectedTileMask = savedTileMasks.length > 1;
  let handleAddBrush = () => {
    let newBrush = Board.toBoolGrid(board);
    setSavedBrushes(v => v.concat([newBrush]));
    setBrush(param => newBrush);
  };
  let handleDeleteSelectedBrush = () => {
    if (selectedSavedBrushIndex !== undefined) {
      return setSavedBrushes(prev => Belt_Array.keepWithIndex(prev, (param, idx) => idx !== selectedSavedBrushIndex));
    }
    
  };
  let handleAddTileMask = () => {
    let newTileMask = Board.toBoolGrid(board);
    setSavedTileMasks(prev => {
      let next = prev.concat([newTileMask]);
      setSelectedTileMaskIndex(param => next.length - 1 | 0);
      return next;
    });
    setTileMask(param => newTileMask);
  };
  let handleDeleteSelectedTileMask = () => {
    if (canDeleteSelectedTileMask) {
      return setSavedTileMasks(prev => {
        let next = Belt_Array.keepWithIndex(prev, (param, idx) => idx !== selectedTileMaskIndex);
        let nextLength = next.length;
        let nextIndex = nextLength === 0 ? 0 : (
            selectedTileMaskIndex >= nextLength ? nextLength - 1 | 0 : selectedTileMaskIndex
          );
        setSelectedTileMaskIndex(param => nextIndex);
        let mask = next[nextIndex];
        if (mask !== undefined) {
          setTileMask(param => mask);
        }
        return next;
      });
    }
    
  };
  let canDeleteCanvas = canvasCount > 1;
  let handleAddCanvas = () => {
    let newBoard = Board.make(boardDimI, boardDimJ);
    let match = computeFitViewForDimensions(boardDimI, boardDimJ);
    let newPan = match[1];
    let fittedZoom = match[0];
    let newCanvas = makeCanvas(fittedZoom, newPan, false, canvasBackgroundColor);
    setCanvases(prev => prev.concat([newCanvas]));
    setCanvasBoards(prev => prev.concat([{
        id: newCanvas.id,
        board: newBoard
      }]));
    setSelectedCanvasId(param => newCanvas.id);
    zoomRef.current = fittedZoom;
    panRef.current = newPan;
    clearHoverRef.current();
    setCursorOverlayOff(param => true);
    lastAutoCenteredDimsRef.current = [
      boardDimI,
      boardDimJ
    ];
  };
  let handleDeleteCanvas = () => {
    if (!canDeleteCanvas) {
      return;
    }
    let currentIndex = Belt_Array.getIndexBy(canvases, canvas => canvas.id === currentCanvasId);
    let nextSelectionId;
    if (currentIndex !== undefined) {
      let nextCanvas = canvases[currentIndex + 1 | 0];
      if (nextCanvas !== undefined) {
        nextSelectionId = nextCanvas.id;
      } else if (currentIndex > 0) {
        let prevCanvas = canvases[currentIndex - 1 | 0];
        nextSelectionId = prevCanvas !== undefined ? prevCanvas.id : undefined;
      } else {
        nextSelectionId = undefined;
      }
    } else {
      nextSelectionId = Stdlib_Option.flatMap(canvases[0], canvas => {
        if (canvas.id === currentCanvasId) {
          return;
        } else {
          return canvas.id;
        }
      });
    }
    setCanvases(prev => Belt_Array.keep(prev, canvas => canvas.id !== currentCanvasId));
    setCanvasBoards(prev => Belt_Array.keep(prev, entry => entry.id !== currentCanvasId));
    if (nextSelectionId !== undefined) {
      setSelectedCanvasId(param => nextSelectionId);
    }
    clearHoverRef.current();
    setCursorOverlayOff(param => true);
  };
  let handleSelectCanvas = canvasId => {
    if (canvasId !== selectedCanvasId) {
      setSelectedCanvasId(param => canvasId);
    }
    clearHoverRef.current();
    setCursorOverlayOff(param => true);
  };
  let onMouseMove = param => setCursorOverlayOff(param => false);
  let getBrushColor = () => {
    if (brushMode === "Color") {
      return myColor;
    } else {
      return null;
    }
  };
  let applyBrush = (clickI, clickJ) => {
    UseLocalStorageJs$1.setLocalStoragePersistencePaused(true);
    let brushColor = getBrushColor();
    updateCanvasBoardById(currentCanvasIdRef.current, prev => {
      let match = Board.dims(prev);
      let cols = match[1];
      let rows = match[0];
      if (rows === 0 || cols === 0) {
        return prev;
      }
      let updates = [];
      for (let brushI = 0; brushI < brushDimI; ++brushI) {
        let boardI = (clickI - brushCenterDimI | 0) + brushI | 0;
        if (boardI >= 0 && boardI < rows) {
          for (let brushJ = 0; brushJ < brushDimJ; ++brushJ) {
            let boardJ = (clickJ - brushCenterDimJ | 0) + brushJ | 0;
            if (boardJ >= 0 && boardJ < cols) {
              let brushAllows = Stdlib_Option.getOr(Array2D.check(brush, brushI, brushJ), false);
              if (brushAllows) {
                let maskAllows = tileMaskDimI > 0 && tileMaskDimJ > 0 ? Stdlib_Option.getOr(Array2D.check(tileMask, Primitive_int.mod_(boardI, tileMaskDimI), Primitive_int.mod_(boardJ, tileMaskDimJ)), false) : true;
                if (maskAllows) {
                  updates.push([
                    boardI,
                    boardJ,
                    brushColor
                  ]);
                }
                
              }
              
            }
            
          }
        }
        
      }
      if (updates.length === 0) {
        return prev;
      } else {
        return Board.setMany(prev, updates);
      }
    });
  };
  React.useEffect(() => {
    window.addEventListener("mousemove", onMouseMove);
    return () => {
      window.removeEventListener("mousemove", onMouseMove);
    };
  }, []);
  React.useEffect(() => {
    let handleKeyDown = event => {
      if (event.metaKey) {
        let match = event.key;
        switch (match) {
          case "[" :
            event.preventDefault();
            let factor = 1 / Initials.zoom_factor;
            return updateZoom(prev => prev * factor);
          case "]" :
            event.preventDefault();
            return updateZoom(prev => prev * Initials.zoom_factor);
          default:
            return;
        }
      } else {
        let match$1 = event.key;
        switch (match$1) {
          case "ArrowDown" :
            event.preventDefault();
            return adjustPan(0, 20);
          case "ArrowLeft" :
            event.preventDefault();
            return adjustPan(- 20, 0);
          case "ArrowRight" :
            event.preventDefault();
            return adjustPan(20, 0);
          case "ArrowUp" :
            event.preventDefault();
            return adjustPan(0, - 20);
          default:
            return;
        }
      }
    };
    window.addEventListener("keydown", handleKeyDown);
    return () => {
      window.removeEventListener("keydown", handleKeyDown);
    };
  }, []);
  let offsetXString = pan[0].toString();
  let offsetYString = pan[1].toString();
  let zoomString = zoom.toString();
  let transformValue = "translate3d(" + offsetXString + "px, " + offsetYString + "px, 0) scale(" + zoomString + ")";
  let onSelectUsedColor = color => {
    setMyColor(param => color);
    setBrushMode(param => "Color");
  };
  let onReplaceUsedColor = color => updateCanvasBoardById(currentCanvasIdRef.current, prev => {
    let match = Board.dims(prev);
    let cols = match[1];
    let replacement = myColor;
    let updates = [];
    for (let row = 0, row_finish = match[0]; row < row_finish; ++row) {
      for (let col = 0; col < cols; ++col) {
        let existing = Board.get(prev, row, col);
        if (!(existing == null) && existing === color) {
          updates.push([
            row,
            col,
            replacement
          ]);
        }
        
      }
    }
    if (updates.length === 0) {
      return prev;
    } else {
      return Board.setMany(prev, updates);
    }
  });
  return JsxRuntime.jsxs("div", {
    children: [
      JsxRuntime.jsxs("div", {
        children: [
          JsxRuntime.jsx(ZoomControl.make, {
            zoomOut: zoomOut,
            zoomIn: zoomIn,
            centerCanvas: centerCanvas,
            fitCanvasToViewport: fitCanvasToViewport,
            zoomPercent: zoomPercent
          }),
          JsxRuntime.jsxs("div", {
            children: [
              JsxRuntime.jsx(SavedBrushesPanel.make, {
                brush: brush,
                setBrush: setBrush,
                savedBrushes: savedBrushes,
                handleAddBrush: handleAddBrush,
                canDeleteSelectedBrush: canDeleteSelectedBrush,
                handleDeleteSelectedBrush: handleDeleteSelectedBrush,
                canSaveBrush: boardDimI <= 32 && boardDimJ <= 32
              }),
              JsxRuntime.jsx(SavedTileMasksPanel.make, {
                setTileMask: setTileMask,
                savedTileMasks: savedTileMasks,
                selectedTileMaskIndex: selectedTileMaskIndex,
                setSelectedTileMaskIndex: setSelectedTileMaskIndex,
                handleAddTileMask: handleAddTileMask,
                canDeleteSelectedTileMask: canDeleteSelectedTileMask,
                handleDeleteSelectedTileMask: handleDeleteSelectedTileMask,
                canSaveTileMask: boardDimI <= 32 && boardDimJ <= 32
              })
            ],
            className: "flex flex-row gap-2 h-full flex-none p-2"
          })
        ],
        className: "flex flex-col flex-none overflow-x-hidden divide-y divide-gray-300"
      }),
      JsxRuntime.jsxs("div", {
        children: [
          JsxRuntime.jsx("div", {
            children: JsxRuntime.jsx(CanvasViewport.make, {
              canvasContainerRef: canvasContainerRef,
              board: board,
              boardDimI: boardDimI,
              boardDimJ: boardDimJ,
              transformValue: transformValue,
              zoom: zoom,
              pan: pan,
              cursorOverlayOff: match$15[0],
              setCursorOverlayOff: setCursorOverlayOff,
              isMouseDown: isMouseDown,
              applyBrush: applyBrush,
              handlePickColor: handlePickColor,
              setHoveredPickColor: setHoveredPickColor,
              isPickingColor: isPickingColor,
              showCursorOverlay: showCursorOverlay,
              overlayMode: overlayMode,
              overlayColor: myColor,
              gridMode: gridMode,
              canvasBackgroundColor: canvasBackgroundColor,
              gridLineColor: gridLineColor,
              checkeredPrimaryColor: checkeredPrimaryColor,
              checkeredSecondaryColor: checkeredSecondaryColor,
              viewportBackgroundColor: viewportBackgroundColor,
              isSilhouette: isSilhouette,
              clearHoverRef: clearHoverRef,
              brush: brush,
              brushDimI: brushDimI,
              brushDimJ: brushDimJ,
              brushCenterDimI: brushCenterDimI,
              brushCenterDimJ: brushCenterDimJ,
              tileMask: tileMask,
              tileMaskDimI: tileMaskDimI,
              tileMaskDimJ: tileMaskDimJ,
              isDotMask: isDotMask
            }),
            className: "flex-1 pt-2"
          }),
          JsxRuntime.jsx(CanvasThumbnails.make, {
            canvases: canvases,
            canvasBoards: canvasBoards,
            currentCanvasId: currentCanvasId,
            canDeleteCanvas: canDeleteCanvas,
            handleDeleteCanvas: handleDeleteCanvas,
            handleAddCanvas: handleAddCanvas,
            handleSelectCanvas: handleSelectCanvas,
            isMouseDown: isMouseDown
          })
        ],
        className: "flex flex-col flex-1 overflow-x-hidden"
      }),
      JsxRuntime.jsxs("div", {
        children: [
          JsxRuntime.jsx(ColorControl.make, {
            brushMode: brushMode,
            setBrushMode: setBrushMode,
            myColor: myColor,
            setMyColor: setMyColor,
            hoveredPickColor: match$20[0],
            isPickingColor: isPickingColor,
            onStartColorPick: onStartColorPick,
            canvasBackgroundColor: canvasBackgroundColor
          }),
          JsxRuntime.jsxs("div", {
            children: [
              JsxRuntime.jsx(ColorsUsed.make, {
                board: board,
                onSelectUsedColor: onSelectUsedColor,
                onReplaceUsedColor: onReplaceUsedColor,
                myColor: myColor,
                isMouseDown: isMouseDown
              }),
              JsxRuntime.jsx(BrushOverlayControl.make, {
                overlayMode: overlayMode,
                setOverlayMode: match$10[1]
              }),
              JsxRuntime.jsx(CanvasGridControl.make, {
                gridMode: gridMode,
                setGridMode: match$11[1]
              }),
              JsxRuntime.jsx(CanvasColorsControl.make, {
                myColor: myColor,
                canvasBackgroundColor: canvasBackgroundColor,
                setCanvasBackgroundColor: setCanvasBackgroundColor,
                viewportBackgroundColor: viewportBackgroundColor,
                setViewportBackgroundColor: match$14[1]
              }),
              JsxRuntime.jsx(SilhouetteControl.make, {
                isSilhouette: isSilhouette,
                setIsSilhouette: match$13[1]
              }),
              JsxRuntime.jsx(DotModeControl.make, {
                isDotMask: isDotMask,
                setCanvasDotMask: setCanvasDotMask
              }),
              JsxRuntime.jsx(CanvasSizeControl.make, {
                resizeRowsInput: resizeRowsInput,
                setResizeRowsInput: setResizeRowsInput,
                resizeColsInput: resizeColsInput,
                setResizeColsInput: setResizeColsInput,
                resizeMode: resizeMode,
                setResizeMode: match$18[1],
                canSubmitResize: canSubmitResize,
                handleResizeSubmit: handleResizeSubmit
              }),
              JsxRuntime.jsx(ExportControl.make, {
                exportScaleInput: exportScaleInput,
                setExportScaleInput: match$16[1],
                includeExportBackground: includeExportBackground,
                setIncludeExportBackground: match$17[1],
                includeExportDotMask: includeExportDotMask,
                setIncludeExportDotMask: setIncludeExportDotMask,
                canExport: canExport,
                onExport: handleExportPng
              })
            ],
            className: "overflow-y-scroll flex-1 flex flex-col py-2 divide-y divide-gray-300"
          })
        ],
        className: " h-full overflow-x-visible flex flex-col w-48 py-2"
      })
    ],
    className: " flex flex-row h-dvh overflow-x-hidden"
  });
}

let make = App;

export {
  make,
}
/* defaultBrushes Not a pure module */
