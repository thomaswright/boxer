// Generated by ReScript, PLEASE EDIT WITH CARE

import * as React from "react";
import * as OtherJs from "./other.js";
import * as Belt_Array from "rescript/lib/es6/Belt_Array.js";
import * as Belt_Float from "rescript/lib/es6/Belt_Float.js";
import * as Stdlib_Int from "rescript/lib/es6/Stdlib_Int.js";
import SwitchJsx from "./Switch.jsx";
import * as Stdlib_Array from "rescript/lib/es6/Stdlib_Array.js";
import * as Primitive_int from "rescript/lib/es6/Primitive_int.js";
import * as Stdlib_Option from "rescript/lib/es6/Stdlib_Option.js";
import * as ReactColorful from "react-colorful";
import * as Stdlib_Nullable from "rescript/lib/es6/Stdlib_Nullable.js";
import * as ExportBoardJs from "./exportBoard.js";
import * as Primitive_option from "rescript/lib/es6/Primitive_option.js";
import * as JsxRuntime from "react/jsx-runtime";
import * as CanvasRendererJs from "./CanvasRenderer.js";
import UseLocalStorageJs from "./useLocalStorage.js";

let make = SwitchJsx;

function make2D(rows, cols, f) {
  return Stdlib_Array.make(rows, undefined).map(() => Stdlib_Array.make(cols, f()));
}

function dims2D(a) {
  let boardDimI = a.length;
  let boardDimJ = Stdlib_Option.mapOr(a[0], 0, line => line.length);
  return [
    boardDimI,
    boardDimJ
  ];
}

function check2D(a, i, j) {
  return Stdlib_Option.flatMap(a[i], row => row[j]);
}

let canvasBackgroundColor = "#ffffff";

let viewportBackgroundColor = "#e5e7eb";

function setRendererSize(prim0, prim1, prim2, prim3) {
  CanvasRendererJs.setRendererSize(prim0, prim1, prim2, prim3);
}

function updateRendererBoard(prim0, prim1, prim2, prim3) {
  CanvasRendererJs.updateBoard(prim0, prim1, prim2, prim3);
}

function updateRendererBrush(prim0, prim1, prim2, prim3) {
  CanvasRendererJs.updateBrush(prim0, prim1, prim2, prim3);
}

function setRendererOverlayOptions(prim0, prim1, prim2) {
  CanvasRendererJs.setOverlayOptions(prim0, prim1, prim2);
}

function generateCanvasId() {
  let timestamp = Date.now().toString();
  let random = Math.random().toString();
  return timestamp + "-" + random;
}

function makeCanvas(board, zoom, pan) {
  return {
    id: generateCanvasId(),
    board: board,
    zoom: zoom,
    pan: pan
  };
}

function useIsMouseDown() {
  let match = React.useState(() => false);
  let setIsMouseDown = match[1];
  React.useEffect(() => {
    let downHandler = param => setIsMouseDown(param => true);
    let upHandler = param => setIsMouseDown(param => false);
    window.addEventListener("mousedown", downHandler);
    window.addEventListener("mouseup", upHandler);
    return () => {
      window.removeEventListener("mousedown", downHandler);
      window.removeEventListener("mouseup", upHandler);
    };
  }, []);
  return match[0];
}

let defaultTileMasks = [
  [
    [
      true,
      true
    ],
    [
      true,
      true
    ]
  ],
  [
    [
      true,
      false
    ],
    [
      false,
      true
    ]
  ],
  [
    [
      false,
      true
    ],
    [
      true,
      false
    ]
  ],
  [
    [
      false,
      true
    ],
    [
      false,
      true
    ]
  ],
  [
    [
      true,
      false
    ],
    [
      true,
      false
    ]
  ],
  [
    [
      false,
      false
    ],
    [
      true,
      true
    ]
  ],
  [
    [
      true,
      true
    ],
    [
      false,
      false
    ]
  ],
  [
    [
      true,
      false,
      false
    ],
    [
      false,
      true,
      false
    ],
    [
      false,
      false,
      true
    ]
  ]
];

let defaultBrushes = [
  make2D(1, 1, () => true),
  make2D(2, 2, () => true),
  make2D(3, 3, () => true),
  make2D(4, 4, () => true),
  make2D(8, 8, () => true),
  make2D(12, 12, () => true),
  make2D(16, 16, () => true)
];

function App$SavedBrushesPanel(props) {
  let handleDeleteSelectedBrush = props.handleDeleteSelectedBrush;
  let canDeleteSelectedBrush = props.canDeleteSelectedBrush;
  let setSavedBrushes = props.setSavedBrushes;
  let setBrush = props.setBrush;
  let brush = props.brush;
  let board = props.board;
  return JsxRuntime.jsxs("div", {
    children: [
      JsxRuntime.jsxs("div", {
        children: [
          JsxRuntime.jsx("button", {
            children: "x",
            className: [
              "w-4 h-4 leading-none",
              canDeleteSelectedBrush ? "bg-red-500 text-white" : "bg-gray-200 text-gray-500 cursor-not-allowed"
            ].join(" "),
            disabled: !canDeleteSelectedBrush,
            onClick: param => handleDeleteSelectedBrush()
          }),
          JsxRuntime.jsx("button", {
            children: "+",
            className: "bg-gray-200 w-4 h-4 leading-none",
            onClick: param => {
              let newBrush = board.map(row => row.map(cell => !(cell == null)));
              setSavedBrushes(v => v.concat([newBrush]));
              setBrush(param => newBrush);
            }
          })
        ]
      }),
      props.savedBrushes.map((savedBrush, savedBrushIndex) => {
        let match = dims2D(savedBrush);
        let dimJ = match[1];
        let dimI = match[0];
        let selected = OtherJs.isEqual2D(brush, savedBrush);
        return JsxRuntime.jsxs("button", {
          children: [
            JsxRuntime.jsx("div", {
              children: dimI.toString() + ":" + dimJ.toString(),
              className: [
                " text-3xs font-bold w-4 text-center bg-white",
                selected ? "text-orange-700" : "text-black"
              ].join(" "),
              style: {
                writingMode: "sideways-lr"
              }
            }),
            JsxRuntime.jsx("div", {
              children: savedBrush.map((line, i) => line.map((cell, j) => JsxRuntime.jsx("div", {
                className: [
                  "w-full h-full ",
                  selected ? (
                      cell ? "bg-orange-500" : "bg-orange-200"
                    ) : (
                      cell ? "bg-gray-400" : "bg-gray-200"
                    )
                ].join(" ")
              }, i.toString() + j.toString()))),
              className: [
                selected ? "bg-orange-500" : "bg-gray-400",
                "flex flex-row h-8 w-8 rounded-xs overflow-hidden"
              ].join(" "),
              style: {
                display: "grid",
                gridTemplateColumns: "repeat(" + dimJ.toString() + ", auto)",
                gridTemplateRows: "repeat(" + dimI.toString() + ", auto)"
              }
            })
          ],
          className: ["flex flex-row"].join(" "),
          onClick: param => setBrush(param => savedBrush)
        }, savedBrushIndex.toString());
      })
    ],
    className: "flex flex-col gap-1 h-full overflow-y-scroll"
  });
}

function App$SavedTileMasksPanel(props) {
  let handleDeleteSelectedTileMask = props.handleDeleteSelectedTileMask;
  let canDeleteSelectedTileMask = props.canDeleteSelectedTileMask;
  let setSelectedTileMaskIndex = props.setSelectedTileMaskIndex;
  let selectedTileMaskIndex = props.selectedTileMaskIndex;
  let setSavedTileMasks = props.setSavedTileMasks;
  let setTileMask = props.setTileMask;
  let board = props.board;
  return JsxRuntime.jsxs("div", {
    children: [
      JsxRuntime.jsxs("div", {
        children: [
          JsxRuntime.jsx("button", {
            children: "x",
            className: [
              "w-4 h-4 leading-none",
              canDeleteSelectedTileMask ? "bg-red-500 text-white" : "bg-gray-200 text-gray-500 cursor-not-allowed"
            ].join(" "),
            disabled: !canDeleteSelectedTileMask,
            onClick: param => handleDeleteSelectedTileMask()
          }),
          JsxRuntime.jsx("button", {
            children: "+",
            className: "bg-gray-200 w-4 h-4 leading-none",
            onClick: param => {
              let newTileMask = board.map(row => row.map(cell => !(cell == null)));
              setSavedTileMasks(prev => {
                let next = prev.concat([newTileMask]);
                setSelectedTileMaskIndex(param => next.length - 1 | 0);
                return next;
              });
              setTileMask(param => newTileMask);
            }
          })
        ]
      }),
      props.savedTileMasks.map((savedTileMask, savedTileMaskIndex) => {
        let match = dims2D(savedTileMask);
        let selected = savedTileMaskIndex === selectedTileMaskIndex;
        return JsxRuntime.jsx("button", {
          children: JsxRuntime.jsx("div", {
            children: savedTileMask.map((line, i) => line.map((cell, j) => JsxRuntime.jsx("div", {
              className: [
                "w-full h-full ",
                selected ? (
                    cell ? "bg-orange-500" : "bg-orange-200"
                  ) : (
                    cell ? "bg-gray-400" : "bg-gray-200"
                  )
              ].join(" ")
            }, i.toString() + j.toString()))),
            className: [
              "h-8 w-8 rounded-xs overflow-hidden",
              selected ? "bg-orange-500 " : "bg-gray-400"
            ].join(" "),
            style: {
              display: "grid",
              gridTemplateColumns: "repeat(" + match[1].toString() + ", auto)",
              gridTemplateRows: "repeat(" + match[0].toString() + ", auto)"
            }
          }),
          onClick: param => {
            setSelectedTileMaskIndex(param => savedTileMaskIndex);
            setTileMask(param => savedTileMask);
          }
        }, savedTileMaskIndex.toString());
      })
    ],
    className: "flex flex-col gap-1 h-full overflow-y-scroll"
  });
}

function hoverToNullable(cell) {
  if (cell !== undefined) {
    return [
      cell[0],
      cell[1]
    ];
  } else {
    return null;
  }
}

function App$CanvasViewport(props) {
  let tileMask = props.tileMask;
  let brushCenterDimJ = props.brushCenterDimJ;
  let brushCenterDimI = props.brushCenterDimI;
  let brush = props.brush;
  let clearHoverRef = props.clearHoverRef;
  let isSilhouette = props.isSilhouette;
  let canvasBackgroundColor = props.canvasBackgroundColor;
  let showCursorOverlay = props.showCursorOverlay;
  let applyBrush = props.applyBrush;
  let isMouseDown = props.isMouseDown;
  let setCursorOverlayOff = props.setCursorOverlayOff;
  let cursorOverlayOff = props.cursorOverlayOff;
  let pan = props.pan;
  let zoom = props.zoom;
  let boardDimJ = props.boardDimJ;
  let boardDimI = props.boardDimI;
  let board = props.board;
  let canvasContainerRef = props.canvasContainerRef;
  let canvasRef = React.useRef(null);
  let rendererRef = React.useRef(undefined);
  let hoveredCellRef = React.useRef(undefined);
  let panY = pan[1];
  let panX = pan[0];
  let withRenderer = callback => {
    let renderer = rendererRef.current;
    if (renderer !== undefined) {
      return callback(Primitive_option.valFromOption(renderer));
    }
    
  };
  React.useEffect(() => {
    let canvasElement = canvasRef.current;
    if (canvasElement == null) {
      return;
    }
    let maybeRenderer = CanvasRendererJs.createCanvasRenderer(canvasElement);
    if (maybeRenderer == null) {
      console.log("Unable to initialize WebGL2 renderer");
      return;
    } else {
      rendererRef.current = Primitive_option.some(maybeRenderer);
      return () => {
        rendererRef.current = undefined;
        CanvasRendererJs.disposeCanvasRenderer(maybeRenderer);
      };
    }
  }, []);
  React.useEffect(() => {
    withRenderer(renderer => {
      setRendererSize(renderer, boardDimJ, boardDimI, 16);
      updateRendererBoard(renderer, board, canvasBackgroundColor, isSilhouette);
      CanvasRendererJs.render(renderer);
      let prim1 = hoverToNullable(hoveredCellRef.current);
      CanvasRendererJs.setHover(renderer, prim1);
    });
  }, [
    board,
    boardDimI,
    boardDimJ,
    canvasBackgroundColor,
    isSilhouette
  ]);
  React.useEffect(() => {
    withRenderer(renderer => {
      updateRendererBrush(renderer, brush, brushCenterDimI, brushCenterDimJ);
      let prim1 = hoverToNullable(hoveredCellRef.current);
      CanvasRendererJs.setHover(renderer, prim1);
    });
  }, [
    brush,
    props.brushDimI,
    props.brushDimJ,
    brushCenterDimI,
    brushCenterDimJ
  ]);
  React.useEffect(() => {
    withRenderer(renderer => {
      CanvasRendererJs.updateTileMask(renderer, tileMask);
      let prim1 = hoverToNullable(hoveredCellRef.current);
      CanvasRendererJs.setHover(renderer, prim1);
    });
  }, [
    tileMask,
    props.tileMaskDimI,
    props.tileMaskDimJ
  ]);
  React.useEffect(() => {
    withRenderer(renderer => {
      let overlayEnabled = showCursorOverlay && !cursorOverlayOff;
      setRendererOverlayOptions(renderer, overlayEnabled, isSilhouette);
      CanvasRendererJs.render(renderer);
    });
  }, [
    showCursorOverlay,
    cursorOverlayOff,
    isSilhouette
  ]);
  let updateHover = hover => {
    hoveredCellRef.current = hover;
    withRenderer(renderer => {
      let prim1 = hoverToNullable(hover);
      CanvasRendererJs.setHover(renderer, prim1);
    });
  };
  React.useEffect(() => {
    clearHoverRef.current = () => updateHover(undefined);
    return () => {
      clearHoverRef.current = () => {};
    };
  }, []);
  let getCellFromEvent = event => {
    let containerElement = canvasContainerRef.current;
    if (containerElement == null) {
      return;
    }
    let rect = containerElement.getBoundingClientRect();
    let clientX = event.clientX;
    let clientY = event.clientY;
    let relativeX = clientX - rect.left;
    let relativeY = clientY - rect.top;
    let boardX = (relativeX - panX) / zoom;
    let boardY = (relativeY - panY) / zoom;
    if (boardX < 0 || boardY < 0) {
      return;
    }
    let col = Math.floor(boardX / 16) | 0;
    let row = Math.floor(boardY / 16) | 0;
    if (col < 0 || col >= boardDimJ || row < 0 || row >= boardDimI) {
      return;
    } else {
      return [
        row,
        col
      ];
    }
  };
  let handleMouseMove = event => {
    setCursorOverlayOff(param => false);
    let cell = getCellFromEvent(event);
    if (cell !== undefined) {
      updateHover(cell);
      if (isMouseDown) {
        return applyBrush(cell[0], cell[1]);
      } else {
        return;
      }
    } else {
      return updateHover(undefined);
    }
  };
  let handleMouseDown = event => {
    let cell = getCellFromEvent(event);
    if (cell !== undefined) {
      updateHover(cell);
      applyBrush(cell[0], cell[1]);
      return setCursorOverlayOff(param => true);
    }
    
  };
  let handleMouseLeave = param => updateHover(undefined);
  let canvasWidth = (boardDimJ << 4);
  let canvasHeight = (boardDimI << 4);
  let widthString = canvasWidth.toString() + "px";
  let heightString = canvasHeight.toString() + "px";
  return JsxRuntime.jsx("div", {
    children: JsxRuntime.jsx("div", {
      children: JsxRuntime.jsx("canvas", {
        ref: Primitive_option.some(canvasRef),
        className: "absolute top-0 left-0 block",
        style: {
          height: heightString,
          imageRendering: "pixelated",
          width: widthString
        },
        onMouseDown: handleMouseDown,
        onMouseEnter: handleMouseMove,
        onMouseLeave: handleMouseLeave,
        onMouseMove: handleMouseMove
      }),
      className: "absolute top-0 left-0",
      style: {
        backgroundColor: canvasBackgroundColor,
        transform: props.transformValue,
        transformOrigin: "top left"
      }
    }),
    ref: Primitive_option.some(canvasContainerRef),
    className: "relative border border-gray-300 overflow-hidden w-full h-full",
    style: {
      backgroundColor: props.viewportBackgroundColor
    }
  });
}

function App$CanvasThumbnails(props) {
  let onSelectCanvas = props.onSelectCanvas;
  let handleAddCanvas = props.handleAddCanvas;
  let handleDeleteCanvas = props.handleDeleteCanvas;
  let canDeleteCanvas = props.canDeleteCanvas;
  let currentCanvasId = props.currentCanvasId;
  return JsxRuntime.jsxs("div", {
    children: [
      props.canvases.map(canvas => {
        let canvasBoard = canvas.board;
        let match = dims2D(canvasBoard);
        let isSelectedCanvas = canvas.id === currentCanvasId;
        return JsxRuntime.jsxs("div", {
          children: [
            JsxRuntime.jsx("button", {
              children: JsxRuntime.jsx("div", {
                children: canvasBoard.map((line, i) => line.map((cell, j) => JsxRuntime.jsx("div", {
                  className: "w-full h-full",
                  style: {
                    backgroundColor: Stdlib_Nullable.getOr(cell, "transparent")
                  }
                }, i.toString() + j.toString()))),
                className: "h-16 w-16 grid",
                style: {
                  gridTemplateColumns: "repeat(" + match[1].toString() + ", minmax(0, 1fr))",
                  gridTemplateRows: "repeat(" + match[0].toString() + ", minmax(0, 1fr))"
                }
              }),
              className: [" w-fit h-fit block"].join(" "),
              onClick: param => onSelectCanvas(canvas.id)
            }),
            isSelectedCanvas ? JsxRuntime.jsx("button", {
                children: "x",
                className: [
                  " w-4 h-4 leading-none text-sm font-medium absolute right-0 bottom-0",
                  canDeleteCanvas ? "bg-red-500 text-white" : "bg-gray-200 text-gray-500 cursor-not-allowed"
                ].join(" "),
                disabled: !canDeleteCanvas,
                onClick: e => {
                  e.stopPropagation();
                  handleDeleteCanvas();
                }
              }) : null
          ],
          className: [
            "relative flex-shrink-0 border-2 w-fit h-fit",
            isSelectedCanvas ? "border-blue-500" : "border-gray-200"
          ].join(" ")
        }, canvas.id);
      }),
      JsxRuntime.jsx("button", {
        children: "+",
        className: "flex-shrink-0 h-16 w-16 border-2 border-dashed border-gray-300 flex items-center justify-center text-3xl text-gray-400",
        onClick: param => handleAddCanvas()
      })
    ],
    className: "flex flex-row items-start gap-3 overflow-x-auto"
  });
}

function App$ColorControl(props) {
  let setMyColor = props.setMyColor;
  let setBrushMode = props.setBrushMode;
  let brushMode = props.brushMode;
  return JsxRuntime.jsxs("div", {
    children: [
      JsxRuntime.jsxs("div", {
        children: [
          JsxRuntime.jsx("button", {
            children: "Color",
            className: [
              brushMode === "Color" ? " bg-blue-500 text-white" : "bg-gray-200",
              "px-2 font-medium rounded"
            ].join(" "),
            onClick: param => setBrushMode(param => "Color")
          }),
          JsxRuntime.jsx("button", {
            children: "Erase",
            className: [
              brushMode === "Erase" ? " bg-blue-500 text-white" : "bg-gray-200",
              "px-2 font-medium rounded"
            ].join(" "),
            onClick: param => setBrushMode(param => "Erase")
          })
        ],
        className: "flex flex-row gap-2 justify-center"
      }),
      JsxRuntime.jsx(ReactColorful.HexColorPicker, {
        color: props.myColor,
        onChange: newColor => setMyColor(param => newColor),
        style: {
          width: "96%"
        }
      })
    ],
    className: "relative flex flex-col gap-2 w-full overflow-x-visible items-center flex-none"
  });
}

function App$CanvasColorsControl(props) {
  let setViewportBackgroundColor = props.setViewportBackgroundColor;
  let setCanvasBackgroundColor = props.setCanvasBackgroundColor;
  let myColor = props.myColor;
  return JsxRuntime.jsxs("div", {
    children: [
      JsxRuntime.jsxs("div", {
        children: [
          JsxRuntime.jsx("span", {
            children: "Canvas Colors",
            className: "font-medium flex-1"
          }),
          JsxRuntime.jsx("button", {
            children: "Default",
            className: "flex flex-row items-center gap-1 text-xs font-medium ml-2",
            type: "button",
            onClick: param => {
              setCanvasBackgroundColor(param => canvasBackgroundColor);
              setViewportBackgroundColor(param => viewportBackgroundColor);
            }
          })
        ],
        className: "flex flex-row"
      }),
      JsxRuntime.jsxs("div", {
        children: [
          JsxRuntime.jsxs("button", {
            children: [
              JsxRuntime.jsx("div", {
                children: "Background",
                className: "flex-1 text-left"
              }),
              JsxRuntime.jsx("div", {
                className: "w-6 h-6 border rounded",
                style: {
                  backgroundColor: props.canvasBackgroundColor
                }
              })
            ],
            className: "flex flex-row items-center gap-1 text-xs font-medium ",
            type: "button",
            onClick: param => setCanvasBackgroundColor(param => myColor)
          }),
          JsxRuntime.jsxs("button", {
            children: [
              JsxRuntime.jsx("div", {
                children: "Viewport",
                className: "flex-1 text-left"
              }),
              JsxRuntime.jsx("div", {
                className: "w-6 h-6 border rounded",
                style: {
                  backgroundColor: props.viewportBackgroundColor
                }
              })
            ],
            className: "flex flex-row items-center gap-1 text-xs font-medium",
            type: "button",
            onClick: param => setViewportBackgroundColor(param => myColor)
          })
        ],
        className: "flex flex-col gap-1"
      })
    ],
    className: " p-2 flex flex-col gap-2 w-full"
  });
}

function App$BrushOverlayControl(props) {
  let setShowCursorOverlay = props.setShowCursorOverlay;
  return JsxRuntime.jsxs("div", {
    children: [
      JsxRuntime.jsx("div", {
        children: "Brush Overlay",
        className: "flex flex-row font-medium"
      }),
      JsxRuntime.jsx(make, {
        checked: props.showCursorOverlay,
        onChange: v => setShowCursorOverlay(param => v)
      })
    ],
    className: "flex flex-row justify-between p-2 w-full"
  });
}

function App$CanvasSizeControl(props) {
  let onSubmitResize = props.onSubmitResize;
  let canSubmitResize = props.canSubmitResize;
  let setResizeMode = props.setResizeMode;
  let resizeMode = props.resizeMode;
  let setResizeColsInput = props.setResizeColsInput;
  let setResizeRowsInput = props.setResizeRowsInput;
  let baseButtonClasses = "flex-1 rounded px-2 py-1 text-xs font-medium border";
  let tmp;
  tmp = resizeMode === "Scale" ? "bg-blue-500 text-white border-blue-500" : "bg-gray-100 text-gray-700 border-gray-300";
  let scaleButtonClasses = [
    baseButtonClasses,
    tmp
  ].join(" ");
  let tmp$1;
  tmp$1 = resizeMode === "Scale" ? "bg-gray-100 text-gray-700 border-gray-300" : "bg-blue-500 text-white border-blue-500";
  let cropButtonClasses = [
    baseButtonClasses,
    tmp$1
  ].join(" ");
  return JsxRuntime.jsxs("div", {
    children: [
      JsxRuntime.jsx("div", {
        children: "Canvas Size",
        className: [
          "flex flex-row items-center justify-between font-medium",
          "w-full"
        ].join(" ")
      }),
      JsxRuntime.jsxs("div", {
        children: [
          JsxRuntime.jsxs("div", {
            children: [
              JsxRuntime.jsx("button", {
                children: "Scale",
                "aria-pressed": resizeMode === "Scale" ? "true" : "false",
                className: scaleButtonClasses,
                type: "button",
                onClick: param => setResizeMode(param => "Scale")
              }),
              JsxRuntime.jsx("button", {
                children: "Crop",
                "aria-pressed": resizeMode === "Crop" ? "true" : "false",
                className: cropButtonClasses,
                type: "button",
                onClick: param => setResizeMode(param => "Crop")
              })
            ],
            className: "flex flex-row gap-2"
          }),
          JsxRuntime.jsxs("div", {
            children: [
              JsxRuntime.jsx("input", {
                className: "border rounded px-2 py-1 text-sm flex-none w-16 ",
                value: props.resizeRowsInput,
                onChange: event => {
                  let value = event.target.value;
                  setResizeRowsInput(param => value);
                }
              }),
              JsxRuntime.jsx("span", {
                children: "x",
                className: "flex-none px-1"
              }),
              JsxRuntime.jsx("input", {
                className: "border rounded px-2 py-1 text-sm flex-none w-16 ",
                value: props.resizeColsInput,
                onChange: event => {
                  let value = event.target.value;
                  setResizeColsInput(param => value);
                }
              })
            ],
            className: "flex flex-row w-full gap-2 justify-between"
          }),
          JsxRuntime.jsx("button", {
            children: "Save",
            className: [
              "rounded px-2 py-1 text-sm font-medium",
              canSubmitResize ? "bg-blue-500 text-white" : "bg-gray-200 text-gray-500 cursor-not-allowed"
            ].join(" "),
            disabled: !canSubmitResize,
            onClick: param => onSubmitResize()
          })
        ],
        className: "flex flex-col gap-2"
      })
    ],
    className: " p-2 flex flex-col gap-2 w-full"
  });
}

function App$ZoomControl(props) {
  let onCenterCanvas = props.onCenterCanvas;
  let onZoomIn = props.onZoomIn;
  let onZoomReset = props.onZoomReset;
  let onZoomOut = props.onZoomOut;
  let zoomPercentString = (props.zoom * 100).toFixed(0);
  return JsxRuntime.jsxs("div", {
    children: [
      JsxRuntime.jsxs("div", {
        children: [
          JsxRuntime.jsx("span", {
            children: "Zoom",
            className: "font-medium"
          }),
          JsxRuntime.jsx("span", {
            children: zoomPercentString + "%",
            className: "text-sm font-mono"
          })
        ],
        className: "flex flex-row items-center justify-between"
      }),
      JsxRuntime.jsxs("div", {
        children: [
          JsxRuntime.jsx("button", {
            children: "-",
            className: "flex-1 rounded px-2 py-1 text-sm font-medium bg-gray-200",
            onClick: param => onZoomOut()
          }),
          JsxRuntime.jsx("button", {
            children: "100%",
            className: "flex-1 rounded px-2 py-1 text-sm font-medium bg-gray-200",
            onClick: param => onZoomReset()
          }),
          JsxRuntime.jsx("button", {
            children: "+",
            className: "flex-1 rounded px-2 py-1 text-sm font-medium bg-gray-200",
            onClick: param => onZoomIn()
          })
        ],
        className: "flex flex-row gap-2"
      }),
      JsxRuntime.jsx("button", {
        children: "Center",
        className: "rounded px-2 py-1 text-sm font-medium bg-gray-200",
        onClick: param => onCenterCanvas()
      })
    ],
    className: "p-2 flex flex-col gap-2 w-full"
  });
}

function App$SilhouetteControl(props) {
  let setIsSilhouette = props.setIsSilhouette;
  return JsxRuntime.jsxs("div", {
    children: [
      JsxRuntime.jsx("div", {
        children: "Silhouette",
        className: "font-medium"
      }),
      JsxRuntime.jsx(make, {
        checked: props.isSilhouette,
        onChange: value => setIsSilhouette(param => value)
      })
    ],
    className: "flex flex-row items-center justify-between p-2 w-full"
  });
}

function App$ExportControl(props) {
  let onExport = props.onExport;
  let canExport = props.canExport;
  let setIncludeBackground = props.setIncludeBackground;
  let setExportScaleInput = props.setExportScaleInput;
  return JsxRuntime.jsxs("div", {
    children: [
      JsxRuntime.jsx("span", {
        children: "Export PNG",
        className: "font-medium"
      }),
      JsxRuntime.jsxs("div", {
        children: [
          JsxRuntime.jsxs("label", {
            children: [
              JsxRuntime.jsx("span", {
                children: "Scale",
                className: "text-xs uppercase tracking-wide text-gray-500"
              }),
              JsxRuntime.jsx("input", {
                className: "border rounded px-2 py-1 text-sm w-16",
                min: "1",
                step: 1.0,
                type: "number",
                value: props.exportScaleInput,
                onChange: event => {
                  let value = event.target.value;
                  setExportScaleInput(param => value);
                }
              })
            ],
            className: "flex flex-col gap-1 text-sm"
          }),
          JsxRuntime.jsx("button", {
            children: "Export",
            className: [
              "rounded px-2 py-1 text-sm font-medium flex-1 h-fit",
              canExport ? "bg-blue-500 text-white" : "bg-gray-200 text-gray-500 cursor-not-allowed"
            ].join(" "),
            disabled: !canExport,
            onClick: param => onExport()
          })
        ],
        className: "flex flex-row  gap-2 items-end"
      }),
      JsxRuntime.jsxs("label", {
        children: [
          JsxRuntime.jsx("input", {
            checked: props.includeBackground,
            type: "checkbox",
            onChange: event => {
              let checked = event.target.checked;
              setIncludeBackground(param => checked);
            }
          }),
          JsxRuntime.jsx("span", {
            children: "Include Background"
          })
        ],
        className: "flex flex-row items-center gap-2 text-sm"
      })
    ],
    className: " p-2 flex flex-col gap-2 w-full"
  });
}

function App$ControlsPanel(props) {
  let myColor = props.myColor;
  return JsxRuntime.jsxs("div", {
    children: [
      JsxRuntime.jsx(App$ColorControl, {
        brushMode: props.brushMode,
        setBrushMode: props.setBrushMode,
        myColor: myColor,
        setMyColor: props.setMyColor
      }),
      JsxRuntime.jsxs("div", {
        children: [
          JsxRuntime.jsx(App$CanvasColorsControl, {
            myColor: myColor,
            canvasBackgroundColor: props.canvasBackgroundColor,
            setCanvasBackgroundColor: props.setCanvasBackgroundColor,
            viewportBackgroundColor: props.viewportBackgroundColor,
            setViewportBackgroundColor: props.setViewportBackgroundColor
          }),
          JsxRuntime.jsx(App$ZoomControl, {
            onZoomOut: props.onZoomOut,
            onZoomReset: props.onZoomReset,
            onZoomIn: props.onZoomIn,
            onCenterCanvas: props.onCenterCanvas,
            zoom: props.zoom
          }),
          JsxRuntime.jsx(App$SilhouetteControl, {
            isSilhouette: props.isSilhouette,
            setIsSilhouette: props.setIsSilhouette
          }),
          JsxRuntime.jsx(App$ExportControl, {
            exportScaleInput: props.exportScaleInput,
            setExportScaleInput: props.setExportScaleInput,
            includeBackground: props.includeExportBackground,
            setIncludeBackground: props.setIncludeExportBackground,
            canExport: props.canExport,
            onExport: props.onExport
          }),
          JsxRuntime.jsx(App$CanvasSizeControl, {
            resizeRowsInput: props.resizeRowsInput,
            setResizeRowsInput: props.setResizeRowsInput,
            resizeColsInput: props.resizeColsInput,
            setResizeColsInput: props.setResizeColsInput,
            resizeMode: props.resizeMode,
            setResizeMode: props.setResizeMode,
            canSubmitResize: props.canSubmitResize,
            onSubmitResize: props.onSubmitResize
          }),
          JsxRuntime.jsx(App$BrushOverlayControl, {
            showCursorOverlay: props.showCursorOverlay,
            setShowCursorOverlay: props.setShowCursorOverlay
          })
        ],
        className: "overflow-y-scroll flex-1 flex flex-col py-2 divide-y divide-gray-300"
      })
    ],
    className: " h-full overflow-x-visible flex flex-col w-48"
  });
}

function App(props) {
  let match = UseLocalStorageJs("brush-mode", "Color");
  let brushMode = match[0];
  let makeDefaultCanvas = () => makeCanvas(make2D(12, 12, () => null), 1, [
    0,
    0
  ]);
  let match$1 = UseLocalStorageJs("canvases", [makeDefaultCanvas()]);
  let setCanvases = match$1[1];
  let canvases = match$1[0];
  let match$2 = UseLocalStorageJs("selected-canvas-id", "");
  let setSelectedCanvasId = match$2[1];
  let selectedCanvasId = match$2[0];
  let match$3 = UseLocalStorageJs("brush", make2D(3, 3, () => true));
  let brush = match$3[0];
  let match$4 = UseLocalStorageJs("saved-brushes", defaultBrushes);
  let setSavedBrushes = match$4[1];
  let savedBrushes = match$4[0];
  let match$5 = UseLocalStorageJs("saved-tile-masks", defaultTileMasks);
  let setSavedTileMasks = match$5[1];
  let savedTileMasks = match$5[0];
  let match$6 = UseLocalStorageJs("selected-tile-mask-index", 0);
  let setSelectedTileMaskIndex = match$6[1];
  let selectedTileMaskIndex = match$6[0];
  let match$7 = UseLocalStorageJs("tile-mask", make2D(4, 4, () => true));
  let setTileMask = match$7[1];
  let tileMask = match$7[0];
  let match$8 = UseLocalStorageJs("show-cursor-overlay", true);
  let showCursorOverlay = match$8[0];
  let match$9 = UseLocalStorageJs("my-color", "blue");
  let myColor = match$9[0];
  let match$10 = UseLocalStorageJs("canvas-background-color", canvasBackgroundColor);
  let canvasBackgroundColor$1 = match$10[0];
  let match$11 = UseLocalStorageJs("viewport-background-color", viewportBackgroundColor);
  let viewportBackgroundColor$1 = match$11[0];
  let match$12 = UseLocalStorageJs("canvas-silhouette", false);
  let isSilhouette = match$12[0];
  let match$13 = React.useState(() => false);
  let setCursorOverlayOff = match$13[1];
  let match$14 = React.useState(() => "1");
  let exportScaleInput = match$14[0];
  let match$15 = React.useState(() => true);
  let includeExportBackground = match$15[0];
  let match$16 = React.useState(() => "Scale");
  let resizeMode = match$16[0];
  let clearHoverRef = React.useRef(() => {});
  let zoomRef = React.useRef(1);
  let panRef = React.useRef([
    0,
    0
  ]);
  let canvasContainerRef = React.useRef(null);
  let match$17 = React.useState(() => [
    192,
    192
  ]);
  let setViewportCenter = match$17[1];
  let viewportCenter = match$17[0];
  let viewportCenterRef = React.useRef(viewportCenter);
  viewportCenterRef.current = viewportCenter;
  let updateViewportCenter = () => {
    let element = canvasContainerRef.current;
    if (element == null) {
      return;
    }
    let rect = element.getBoundingClientRect();
    setViewportCenter(param => [
      rect.width / 2,
      rect.height / 2
    ]);
  };
  React.useEffect(() => {
    updateViewportCenter();
    let handleResize = param => updateViewportCenter();
    window.addEventListener("resize", handleResize);
    return () => {
      window.removeEventListener("resize", handleResize);
    };
  }, []);
  let clampZoom = value => {
    let cappedMax = value > 4 ? 4 : value;
    if (cappedMax < 0.25) {
      return 0.25;
    } else {
      return cappedMax;
    }
  };
  let isMouseDown = useIsMouseDown();
  let canvasCount = canvases.length;
  React.useEffect(() => {
    if (canvasCount === 0) {
      let defaultCanvas = makeDefaultCanvas();
      setCanvases(param => [defaultCanvas]);
      setSelectedCanvasId(param => defaultCanvas.id);
    }
    
  }, []);
  let canvas = Belt_Array.getBy(canvases, canvas => canvas.id === selectedCanvasId);
  let currentCanvas;
  if (canvas !== undefined) {
    currentCanvas = canvas;
  } else {
    let firstCanvas = canvases[0];
    currentCanvas = firstCanvas !== undefined ? firstCanvas : makeDefaultCanvas();
  }
  let currentCanvasId = currentCanvas.id;
  let currentCanvasIdRef = React.useRef(currentCanvasId);
  currentCanvasIdRef.current = currentCanvasId;
  React.useEffect(() => {
    let hasValidSelection = Belt_Array.some(canvases, canvas => canvas.id === selectedCanvasId);
    if (!hasValidSelection) {
      let firstCanvas = canvases[0];
      if (firstCanvas !== undefined && firstCanvas.id !== selectedCanvasId) {
        setSelectedCanvasId(param => firstCanvas.id);
      }
      
    }
    
  }, [
    canvases,
    selectedCanvasId
  ]);
  React.useEffect(() => {
    let requiresMigration = Belt_Array.some(canvases, canvas => {
      if (typeof canvas.id !== "string") {
        return true;
      } else {
        return canvas.id === "";
      }
    });
    if (requiresMigration) {
      setCanvases(prev => prev.map((canvas, idx) => {
        if (typeof canvas.id === "string" && canvas.id !== "") {
          return canvas;
        }
        let uniqueSuffix = "-" + idx.toString();
        return {
          id: generateCanvasId() + uniqueSuffix,
          board: canvas.board,
          zoom: canvas.zoom,
          pan: canvas.pan
        };
      }));
    }
    
  }, canvases);
  let board = currentCanvas.board;
  let zoom = currentCanvas.zoom;
  let pan = currentCanvas.pan;
  zoomRef.current = zoom;
  panRef.current = pan;
  let updateCanvasById = (targetId, updater) => setCanvases(prev => {
    if (prev.length === 0) {
      return [updater(makeDefaultCanvas())];
    } else {
      return prev.map(canvas => {
        if (canvas.id === targetId) {
          return updater(canvas);
        } else {
          return canvas;
        }
      });
    }
  });
  let setBoard = updater => updateCanvasById(currentCanvasIdRef.current, canvas => ({
    id: canvas.id,
    board: updater(canvas.board),
    zoom: canvas.zoom,
    pan: canvas.pan
  }));
  let updatePan = updater => updateCanvasById(currentCanvasIdRef.current, canvas => {
    let nextPan = updater(canvas.pan);
    panRef.current = nextPan;
    return {
      id: canvas.id,
      board: canvas.board,
      zoom: canvas.zoom,
      pan: nextPan
    };
  });
  let adjustPan = (deltaX, deltaY) => updatePan(param => [
    param[0] + deltaX,
    param[1] + deltaY
  ]);
  let updateZoom = updater => updateCanvasById(currentCanvasIdRef.current, canvas => {
    let prevZoom = canvas.zoom;
    let nextZoom = clampZoom(updater(prevZoom));
    if (nextZoom !== prevZoom) {
      let match = viewportCenterRef.current;
      let centerY = match[1];
      let centerX = match[0];
      let match$1 = canvas.pan;
      let boardCenterX = (centerX - match$1[0]) / prevZoom;
      let boardCenterY = (centerY - match$1[1]) / prevZoom;
      let nextPanX = centerX - boardCenterX * nextZoom;
      let nextPanY = centerY - boardCenterY * nextZoom;
      let nextPan = [
        nextPanX,
        nextPanY
      ];
      zoomRef.current = nextZoom;
      panRef.current = nextPan;
      return {
        id: canvas.id,
        board: canvas.board,
        zoom: nextZoom,
        pan: nextPan
      };
    }
    zoomRef.current = nextZoom;
    return canvas;
  });
  let resetZoom = () => updateZoom(param => 1);
  let zoomIn = () => updateZoom(prev => prev * 1.1);
  let zoomOut = () => {
    let factor = 1 / 1.1;
    updateZoom(prev => prev * factor);
  };
  let match$18 = dims2D(board);
  let boardDimJ = match$18[1];
  let boardDimI = match$18[0];
  let lastAutoCenteredDimsRef = React.useRef(undefined);
  let match$19 = dims2D(brush);
  let brushDimJ = match$19[1];
  let brushDimI = match$19[0];
  let brushCenterDimI = brushDimI / 2 | 0;
  let brushCenterDimJ = brushDimJ / 2 | 0;
  let match$20 = dims2D(tileMask);
  let tileMaskDimJ = match$20[1];
  let tileMaskDimI = match$20[0];
  let computeCenteredPan = (dimI, dimJ, zoomValue) => {
    let boardWidth = dimI * 16;
    let boardHeight = dimJ * 16;
    let nextPanX = viewportCenter[0] - boardWidth * zoomValue / 2;
    let nextPanY = viewportCenter[1] - boardHeight * zoomValue / 2;
    return [
      nextPanX,
      nextPanY
    ];
  };
  let centerCanvas = () => {
    let match = computeCenteredPan(boardDimI, boardDimJ, zoomRef.current);
    let nextPanY = match[1];
    let nextPanX = match[0];
    updatePan(param => {
      let prevY = param[1];
      let prevX = param[0];
      if (prevX === nextPanX && prevY === nextPanY) {
        return [
          prevX,
          prevY
        ];
      } else {
        return [
          nextPanX,
          nextPanY
        ];
      }
    });
  };
  let centerCanvasForDimensions = (dimI, dimJ) => {
    let match = computeCenteredPan(dimI, dimJ, zoomRef.current);
    let nextPanY = match[1];
    let nextPanX = match[0];
    updatePan(param => {
      let prevY = param[1];
      let prevX = param[0];
      if (prevX === nextPanX && prevY === nextPanY) {
        return [
          prevX,
          prevY
        ];
      } else {
        return [
          nextPanX,
          nextPanY
        ];
      }
    });
  };
  let match$21 = React.useState(() => boardDimI.toString());
  let setResizeRowsInput = match$21[1];
  let resizeRowsInput = match$21[0];
  let match$22 = React.useState(() => boardDimJ.toString());
  let setResizeColsInput = match$22[1];
  let resizeColsInput = match$22[0];
  React.useEffect(() => {
    setResizeRowsInput(param => boardDimI.toString());
    setResizeColsInput(param => boardDimJ.toString());
  }, [
    boardDimI,
    boardDimJ
  ]);
  React.useEffect(() => {
    let match = lastAutoCenteredDimsRef.current;
    let shouldCenter = match !== undefined ? match[0] !== boardDimI || match[1] !== boardDimJ : true;
    let match$1 = panRef.current;
    if (shouldCenter || match$1[0] === 0 && match$1[1] === 0) {
      centerCanvasForDimensions(boardDimI, boardDimJ);
      lastAutoCenteredDimsRef.current = [
        boardDimI,
        boardDimJ
      ];
    }
    
  }, [
    boardDimI,
    boardDimJ,
    viewportCenter
  ]);
  React.useEffect(() => {
    let mask = savedTileMasks[selectedTileMaskIndex];
    if (mask !== undefined) {
      if (!OtherJs.isEqual2D(mask, tileMask)) {
        setTileMask(param => mask);
      }
      return;
    }
    if (savedTileMasks.length > 0) {
      let fallbackIndex = selectedTileMaskIndex >= savedTileMasks.length ? savedTileMasks.length - 1 | 0 : 0;
      setSelectedTileMaskIndex(param => fallbackIndex);
    }
    
  }, [
    savedTileMasks,
    selectedTileMaskIndex
  ]);
  let parsePositiveInt = value => {
    let parsed = Stdlib_Int.fromString(value, undefined);
    if (parsed !== undefined && parsed > 0) {
      return parsed;
    }
    
  };
  let parsePositiveFloat = value => {
    let parsed = Belt_Float.fromString(value);
    if (parsed !== undefined && parsed > 0) {
      return parsed;
    }
    
  };
  let mapIndex = (srcSize, dstSize, index) => {
    if (srcSize <= 1 || dstSize <= 1) {
      return 0;
    }
    let numerator = (index * (srcSize - 1 | 0) | 0) + ((dstSize - 1 | 0) / 2 | 0) | 0;
    let denominator = dstSize - 1 | 0;
    let mapped = Primitive_int.div(numerator, denominator);
    let maxIndex = srcSize - 1 | 0;
    if (mapped < 0) {
      return 0;
    } else if (mapped > maxIndex) {
      return maxIndex;
    } else {
      return mapped;
    }
  };
  let match$23 = parsePositiveInt(resizeRowsInput);
  let match$24 = parsePositiveInt(resizeColsInput);
  let canSubmitResize = match$23 !== undefined && match$24 !== undefined ? match$23 !== boardDimI || match$24 !== boardDimJ : false;
  let exportScaleValue = parsePositiveFloat(exportScaleInput);
  let canExport = Stdlib_Option.isSome(exportScaleValue);
  let handleResizeSubmit = () => {
    let match = parsePositiveInt(resizeRowsInput);
    let match$1 = parsePositiveInt(resizeColsInput);
    if (match === undefined) {
      return;
    }
    if (match$1 === undefined) {
      return;
    }
    if (resizeMode === "Scale") {
      setBoard(prev => {
        let match$2 = dims2D(prev);
        let prevCols = match$2[1];
        let prevRows = match$2[0];
        if (prevRows === 0 || prevCols === 0) {
          return make2D(match, match$1, () => null);
        } else {
          return make2D(match, match$1, () => null).map((row, rowI) => row.map((param, colJ) => {
            let srcRow = mapIndex(prevRows, match, rowI);
            let srcCol = mapIndex(prevCols, match$1, colJ);
            return Stdlib_Option.getOr(check2D(prev, srcRow, srcCol), null);
          }));
        }
      });
    } else {
      setBoard(prev => make2D(match, match$1, () => null).map((row, rowI) => row.map((param, colJ) => Stdlib_Option.getOr(check2D(prev, rowI, colJ), null))));
    }
    clearHoverRef.current();
    setCursorOverlayOff(param => true);
  };
  let handleExportPng = () => {
    if (exportScaleValue !== undefined) {
      let prim2 = {
        includeBackground: includeExportBackground,
        backgroundColor: canvasBackgroundColor$1
      };
      ExportBoardJs.exportBoardAsPng(board, exportScaleValue, prim2);
      return;
    }
    
  };
  let selectedSavedBrushIndex = Belt_Array.getIndexBy(savedBrushes, savedBrush => OtherJs.isEqual2D(savedBrush, brush));
  let canDeleteSelectedBrush = Stdlib_Option.isSome(selectedSavedBrushIndex);
  let canDeleteSelectedTileMask = savedTileMasks.length > 1;
  let handleDeleteSelectedBrush = () => {
    if (selectedSavedBrushIndex !== undefined) {
      return setSavedBrushes(prev => Belt_Array.keepWithIndex(prev, (param, idx) => idx !== selectedSavedBrushIndex));
    }
    
  };
  let handleDeleteSelectedTileMask = () => {
    if (canDeleteSelectedTileMask) {
      return setSavedTileMasks(prev => {
        let next = Belt_Array.keepWithIndex(prev, (param, idx) => idx !== selectedTileMaskIndex);
        let nextLength = next.length;
        let nextIndex = nextLength === 0 ? 0 : (
            selectedTileMaskIndex >= nextLength ? nextLength - 1 | 0 : selectedTileMaskIndex
          );
        setSelectedTileMaskIndex(param => nextIndex);
        let mask = next[nextIndex];
        if (mask !== undefined) {
          setTileMask(param => mask);
        }
        return next;
      });
    }
    
  };
  let canDeleteCanvas = canvasCount > 1;
  let handleAddCanvas = () => {
    let newBoard = make2D(boardDimI, boardDimJ, () => null);
    let newPan = computeCenteredPan(boardDimI, boardDimJ, 1);
    let newCanvas = makeCanvas(newBoard, 1, newPan);
    setCanvases(prev => prev.concat([newCanvas]));
    setSelectedCanvasId(param => newCanvas.id);
    clearHoverRef.current();
    setCursorOverlayOff(param => true);
    lastAutoCenteredDimsRef.current = [
      boardDimI,
      boardDimJ
    ];
  };
  let handleDeleteCanvas = () => {
    if (!canDeleteCanvas) {
      return;
    }
    let currentIndex = Belt_Array.getIndexBy(canvases, canvas => canvas.id === currentCanvasId);
    let nextSelectionId;
    if (currentIndex !== undefined) {
      let nextCanvas = canvases[currentIndex + 1 | 0];
      if (nextCanvas !== undefined) {
        nextSelectionId = nextCanvas.id;
      } else if (currentIndex > 0) {
        let prevCanvas = canvases[currentIndex - 1 | 0];
        nextSelectionId = prevCanvas !== undefined ? prevCanvas.id : undefined;
      } else {
        nextSelectionId = undefined;
      }
    } else {
      nextSelectionId = Stdlib_Option.flatMap(canvases[0], canvas => {
        if (canvas.id === currentCanvasId) {
          return;
        } else {
          return canvas.id;
        }
      });
    }
    setCanvases(prev => Belt_Array.keep(prev, canvas => canvas.id !== currentCanvasId));
    if (nextSelectionId !== undefined) {
      setSelectedCanvasId(param => nextSelectionId);
    }
    clearHoverRef.current();
    setCursorOverlayOff(param => true);
  };
  let handleSelectCanvas = canvasId => {
    if (canvasId !== selectedCanvasId) {
      setSelectedCanvasId(param => canvasId);
    }
    clearHoverRef.current();
    setCursorOverlayOff(param => true);
  };
  let onMouseMove = param => setCursorOverlayOff(param => false);
  let canApply = (boardI, boardJ, clickI, clickJ) => {
    let brushPosI = (boardI - clickI | 0) + brushCenterDimI | 0;
    let brushPosJ = (boardJ - clickJ | 0) + brushCenterDimJ | 0;
    let brushAllows = Stdlib_Option.getOr(check2D(brush, brushPosI, brushPosJ), false);
    let maskAllows = Stdlib_Option.getOr(check2D(tileMask, Primitive_int.mod_(boardI, tileMaskDimI), Primitive_int.mod_(boardJ, tileMaskDimJ)), false);
    if (brushAllows) {
      return maskAllows;
    } else {
      return false;
    }
  };
  let getBrushColor = () => {
    if (brushMode === "Color") {
      return myColor;
    } else {
      return null;
    }
  };
  let applyBrush = (clickI, clickJ) => setBoard(b => b.map((row, boardI) => row.map((cell, boardJ) => {
    if (canApply(boardI, boardJ, clickI, clickJ)) {
      return getBrushColor();
    } else {
      return cell;
    }
  })));
  React.useEffect(() => {
    window.addEventListener("mousemove", onMouseMove);
    return () => {
      window.removeEventListener("mousemove", onMouseMove);
    };
  }, []);
  React.useEffect(() => {
    let handleKeyDown = event => {
      if (event.metaKey) {
        let match = event.key;
        switch (match) {
          case "[" :
            event.preventDefault();
            let factor = 1 / 1.1;
            return updateZoom(prev => prev * factor);
          case "]" :
            event.preventDefault();
            return updateZoom(prev => prev * 1.1);
          default:
            return;
        }
      } else {
        let step = 16 / zoomRef.current;
        let match$1 = event.key;
        switch (match$1) {
          case "ArrowDown" :
            event.preventDefault();
            return adjustPan(0, step);
          case "ArrowLeft" :
            event.preventDefault();
            return adjustPan(- step, 0);
          case "ArrowRight" :
            event.preventDefault();
            return adjustPan(step, 0);
          case "ArrowUp" :
            event.preventDefault();
            return adjustPan(0, - step);
          default:
            return;
        }
      }
    };
    window.addEventListener("keydown", handleKeyDown);
    return () => {
      window.removeEventListener("keydown", handleKeyDown);
    };
  }, []);
  let offsetXString = pan[0].toString();
  let offsetYString = pan[1].toString();
  let zoomString = zoom.toString();
  let transformValue = "translate3d(" + offsetXString + "px, " + offsetYString + "px, 0) scale(" + zoomString + ")";
  return JsxRuntime.jsxs("div", {
    children: [
      JsxRuntime.jsxs("div", {
        children: [
          JsxRuntime.jsx(App$SavedBrushesPanel, {
            board: board,
            brush: brush,
            setBrush: match$3[1],
            savedBrushes: savedBrushes,
            setSavedBrushes: setSavedBrushes,
            canDeleteSelectedBrush: canDeleteSelectedBrush,
            handleDeleteSelectedBrush: handleDeleteSelectedBrush
          }),
          JsxRuntime.jsx(App$SavedTileMasksPanel, {
            board: board,
            setTileMask: setTileMask,
            savedTileMasks: savedTileMasks,
            setSavedTileMasks: setSavedTileMasks,
            selectedTileMaskIndex: selectedTileMaskIndex,
            setSelectedTileMaskIndex: setSelectedTileMaskIndex,
            canDeleteSelectedTileMask: canDeleteSelectedTileMask,
            handleDeleteSelectedTileMask: handleDeleteSelectedTileMask
          })
        ],
        className: "flex flex-row gap-2 h-full flex-none"
      }),
      JsxRuntime.jsxs("div", {
        children: [
          JsxRuntime.jsx("div", {
            children: JsxRuntime.jsx(App$CanvasViewport, {
              canvasContainerRef: canvasContainerRef,
              board: board,
              boardDimI: boardDimI,
              boardDimJ: boardDimJ,
              transformValue: transformValue,
              zoom: zoom,
              pan: pan,
              cursorOverlayOff: match$13[0],
              setCursorOverlayOff: setCursorOverlayOff,
              isMouseDown: isMouseDown,
              applyBrush: applyBrush,
              showCursorOverlay: showCursorOverlay,
              canvasBackgroundColor: canvasBackgroundColor$1,
              viewportBackgroundColor: viewportBackgroundColor$1,
              isSilhouette: isSilhouette,
              clearHoverRef: clearHoverRef,
              brush: brush,
              brushDimI: brushDimI,
              brushDimJ: brushDimJ,
              brushCenterDimI: brushCenterDimI,
              brushCenterDimJ: brushCenterDimJ,
              tileMask: tileMask,
              tileMaskDimI: tileMaskDimI,
              tileMaskDimJ: tileMaskDimJ
            }),
            className: "flex-1"
          }),
          JsxRuntime.jsx("div", {
            children: JsxRuntime.jsx(App$CanvasThumbnails, {
              canvases: canvases,
              currentCanvasId: currentCanvasId,
              canDeleteCanvas: canDeleteCanvas,
              handleDeleteCanvas: handleDeleteCanvas,
              handleAddCanvas: handleAddCanvas,
              onSelectCanvas: handleSelectCanvas
            }),
            className: "flex-none flex flex-col gap-2 w-full"
          })
        ],
        className: "flex flex-col gap-2 flex-1"
      }),
      JsxRuntime.jsx(App$ControlsPanel, {
        brushMode: brushMode,
        setBrushMode: match[1],
        myColor: myColor,
        setMyColor: match$9[1],
        canvasBackgroundColor: canvasBackgroundColor$1,
        setCanvasBackgroundColor: match$10[1],
        viewportBackgroundColor: viewportBackgroundColor$1,
        setViewportBackgroundColor: match$11[1],
        isSilhouette: isSilhouette,
        setIsSilhouette: match$12[1],
        showCursorOverlay: showCursorOverlay,
        setShowCursorOverlay: match$8[1],
        resizeMode: resizeMode,
        setResizeMode: match$16[1],
        resizeRowsInput: resizeRowsInput,
        setResizeRowsInput: setResizeRowsInput,
        resizeColsInput: resizeColsInput,
        setResizeColsInput: setResizeColsInput,
        canSubmitResize: canSubmitResize,
        onSubmitResize: handleResizeSubmit,
        zoom: zoom,
        onZoomIn: zoomIn,
        onZoomOut: zoomOut,
        onZoomReset: resetZoom,
        onCenterCanvas: centerCanvas,
        exportScaleInput: exportScaleInput,
        setExportScaleInput: match$14[1],
        includeExportBackground: includeExportBackground,
        setIncludeExportBackground: match$15[1],
        canExport: canExport,
        onExport: handleExportPng
      })
    ],
    className: " flex flex-row gap-5 p-3 h-dvh overflow-x-hidden"
  });
}

let make$1 = App;

export {
  make$1 as make,
}
/* make Not a pure module */
