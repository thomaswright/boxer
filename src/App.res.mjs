// Generated by ReScript, PLEASE EDIT WITH CARE

import * as React from "react";
import * as OtherJs from "./other.js";
import * as Belt_Array from "rescript/lib/es6/Belt_Array.js";
import * as Belt_Float from "rescript/lib/es6/Belt_Float.js";
import * as Stdlib_Int from "rescript/lib/es6/Stdlib_Int.js";
import SwitchJsx from "./Switch.jsx";
import * as Color from "@texel/color";
import * as Stdlib_Array from "rescript/lib/es6/Stdlib_Array.js";
import * as Primitive_int from "rescript/lib/es6/Primitive_int.js";
import * as Stdlib_Option from "rescript/lib/es6/Stdlib_Option.js";
import * as ReactColorful from "react-colorful";
import * as Stdlib_Nullable from "rescript/lib/es6/Stdlib_Nullable.js";
import * as ExportBoardJs from "./exportBoard.js";
import * as Primitive_option from "rescript/lib/es6/Primitive_option.js";
import * as JsxRuntime from "react/jsx-runtime";
import UseLocalStorageJs from "./useLocalStorage.js";

let make = SwitchJsx;

function make2D(rows, cols, f) {
  return Stdlib_Array.make(rows, undefined).map(() => Stdlib_Array.make(cols, f()));
}

function dims2D(a) {
  let boardDimI = a.length;
  let boardDimJ = Stdlib_Option.mapOr(a[0], 0, line => line.length);
  return [
    boardDimI,
    boardDimJ
  ];
}

function check2D(a, i, j) {
  return Stdlib_Option.flatMap(a[i], row => row[j]);
}

let canvasBackgroundColor = "#ffffff";

let viewportBackgroundColor = "#e5e7eb";

function useIsMouseDown() {
  let match = React.useState(() => false);
  let setIsMouseDown = match[1];
  React.useEffect(() => {
    let downHandler = param => setIsMouseDown(param => true);
    let upHandler = param => setIsMouseDown(param => false);
    window.addEventListener("mousedown", downHandler);
    window.addEventListener("mouseup", upHandler);
    return () => {
      window.removeEventListener("mousedown", downHandler);
      window.removeEventListener("mouseup", upHandler);
    };
  }, []);
  return match[0];
}

function isLight(color) {
  let match = Color.convert(Color.hexToRGB(color), Color.sRGB, Color.OKHSL);
  return match[2] > 0.5;
}

let defaultTileMasks = [
  [
    [
      true,
      true
    ],
    [
      true,
      true
    ]
  ],
  [
    [
      true,
      false
    ],
    [
      false,
      true
    ]
  ],
  [
    [
      false,
      true
    ],
    [
      true,
      false
    ]
  ],
  [
    [
      false,
      true
    ],
    [
      false,
      true
    ]
  ],
  [
    [
      true,
      false
    ],
    [
      true,
      false
    ]
  ],
  [
    [
      false,
      false
    ],
    [
      true,
      true
    ]
  ],
  [
    [
      true,
      true
    ],
    [
      false,
      false
    ]
  ],
  [
    [
      true,
      false,
      false
    ],
    [
      false,
      true,
      false
    ],
    [
      false,
      false,
      true
    ]
  ]
];

let defaultBrushes = [
  make2D(1, 1, () => true),
  make2D(2, 2, () => true),
  make2D(3, 3, () => true),
  make2D(4, 4, () => true),
  make2D(8, 8, () => true),
  make2D(12, 12, () => true),
  make2D(16, 16, () => true)
];

function App$SavedBrushesPanel(props) {
  let handleDeleteSelectedBrush = props.handleDeleteSelectedBrush;
  let canDeleteSelectedBrush = props.canDeleteSelectedBrush;
  let setSavedBrushes = props.setSavedBrushes;
  let setBrush = props.setBrush;
  let brush = props.brush;
  let board = props.board;
  return JsxRuntime.jsxs("div", {
    children: [
      JsxRuntime.jsxs("div", {
        children: [
          JsxRuntime.jsx("button", {
            children: "x",
            className: [
              "w-4 h-4 leading-none",
              canDeleteSelectedBrush ? "bg-red-500 text-white" : "bg-gray-200 text-gray-500 cursor-not-allowed"
            ].join(" "),
            disabled: !canDeleteSelectedBrush,
            onClick: param => handleDeleteSelectedBrush()
          }),
          JsxRuntime.jsx("button", {
            children: "+",
            className: "bg-gray-200 w-4 h-4 leading-none",
            onClick: param => {
              let newBrush = board.map(row => row.map(cell => !(cell == null)));
              setSavedBrushes(v => v.concat([newBrush]));
              setBrush(param => newBrush);
            }
          })
        ]
      }),
      props.savedBrushes.map((savedBrush, savedBrushIndex) => {
        let match = dims2D(savedBrush);
        let dimJ = match[1];
        let dimI = match[0];
        let selected = OtherJs.isEqual2D(brush, savedBrush);
        return JsxRuntime.jsxs("button", {
          children: [
            JsxRuntime.jsx("div", {
              children: dimI.toString() + ":" + dimJ.toString(),
              className: [
                " text-3xs font-bold w-4 text-center bg-white",
                selected ? "text-orange-700" : "text-black"
              ].join(" "),
              style: {
                writingMode: "sideways-lr"
              }
            }),
            JsxRuntime.jsx("div", {
              children: savedBrush.map((line, i) => line.map((cell, j) => JsxRuntime.jsx("div", {
                className: [
                  "w-full h-full ",
                  selected ? (
                      cell ? "bg-orange-500" : "bg-orange-200"
                    ) : (
                      cell ? "bg-gray-400" : "bg-gray-200"
                    )
                ].join(" ")
              }, i.toString() + j.toString()))),
              className: [
                selected ? "bg-orange-500" : "bg-gray-400",
                "flex flex-row h-8 w-8 rounded-xs overflow-hidden"
              ].join(" "),
              style: {
                display: "grid",
                gridTemplateColumns: "repeat(" + dimI.toString() + ", auto)",
                gridTemplateRows: "repeat(" + dimJ.toString() + ", auto)"
              }
            })
          ],
          className: ["flex flex-row"].join(" "),
          onClick: param => setBrush(param => savedBrush)
        }, savedBrushIndex.toString());
      })
    ],
    className: "flex flex-col gap-1 h-full overflow-y-scroll"
  });
}

function App$SavedTileMasksPanel(props) {
  let handleDeleteSelectedTileMask = props.handleDeleteSelectedTileMask;
  let canDeleteSelectedTileMask = props.canDeleteSelectedTileMask;
  let setSelectedTileMaskIndex = props.setSelectedTileMaskIndex;
  let selectedTileMaskIndex = props.selectedTileMaskIndex;
  let setSavedTileMasks = props.setSavedTileMasks;
  let setTileMask = props.setTileMask;
  let board = props.board;
  return JsxRuntime.jsxs("div", {
    children: [
      JsxRuntime.jsxs("div", {
        children: [
          JsxRuntime.jsx("button", {
            children: "x",
            className: [
              "w-4 h-4 leading-none",
              canDeleteSelectedTileMask ? "bg-red-500 text-white" : "bg-gray-200 text-gray-500 cursor-not-allowed"
            ].join(" "),
            disabled: !canDeleteSelectedTileMask,
            onClick: param => handleDeleteSelectedTileMask()
          }),
          JsxRuntime.jsx("button", {
            children: "+",
            className: "bg-gray-200 w-4 h-4 leading-none",
            onClick: param => {
              let newTileMask = board.map(row => row.map(cell => !(cell == null)));
              setSavedTileMasks(prev => {
                let next = prev.concat([newTileMask]);
                setSelectedTileMaskIndex(param => next.length - 1 | 0);
                return next;
              });
              setTileMask(param => newTileMask);
            }
          })
        ]
      }),
      props.savedTileMasks.map((savedTileMask, savedTileMaskIndex) => {
        let match = dims2D(savedTileMask);
        let selected = savedTileMaskIndex === selectedTileMaskIndex;
        return JsxRuntime.jsx("button", {
          children: JsxRuntime.jsx("div", {
            children: savedTileMask.map((line, i) => line.map((cell, j) => JsxRuntime.jsx("div", {
              className: [
                "w-full h-full ",
                selected ? (
                    cell ? "bg-orange-500" : "bg-orange-200"
                  ) : (
                    cell ? "bg-gray-400" : "bg-gray-200"
                  )
              ].join(" ")
            }, i.toString() + j.toString()))),
            className: [
              "h-8 w-8 rounded-xs overflow-hidden",
              selected ? "bg-orange-500 " : "bg-gray-400"
            ].join(" "),
            style: {
              display: "grid",
              gridTemplateColumns: "repeat(" + match[0].toString() + ", auto)",
              gridTemplateRows: "repeat(" + match[1].toString() + ", auto)"
            }
          }),
          onClick: param => {
            setSelectedTileMaskIndex(param => savedTileMaskIndex);
            setTileMask(param => savedTileMask);
          }
        }, savedTileMaskIndex.toString());
      })
    ],
    className: "flex flex-col gap-1 h-full overflow-y-scroll"
  });
}

function App$CanvasViewport(props) {
  let isSilhouette = props.isSilhouette;
  let showCursorOverlay = props.showCursorOverlay;
  let canApply = props.canApply;
  let applyBrush = props.applyBrush;
  let isMouseDown = props.isMouseDown;
  let setCursorOverlayOff = props.setCursorOverlayOff;
  let cursorOverlayOff = props.cursorOverlayOff;
  let setHoveredCell = props.setHoveredCell;
  let hoveredCell = props.hoveredCell;
  return JsxRuntime.jsx("div", {
    children: JsxRuntime.jsx("div", {
      children: props.board.map((line, i) => line.map((cell, j) => {
        let cellColor = isSilhouette ? Stdlib_Nullable.mapOr(cell, "transparent", param => "#000000") : Stdlib_Nullable.getOr(cell, "transparent");
        let overlayBackgroundColor = isSilhouette ? "white" : Stdlib_Nullable.mapOr(cell, "black", value => {
            if (isLight(value)) {
              return "black";
            } else {
              return "white";
            }
          });
        return JsxRuntime.jsxs("div", {
          children: [
            JsxRuntime.jsx("div", {
              className: "w-full h-full absolute",
              style: {
                backgroundColor: cellColor
              }
            }),
            hoveredCell !== undefined && !(cursorOverlayOff || !showCursorOverlay || !canApply(i, j, hoveredCell[0], hoveredCell[1])) ? JsxRuntime.jsx("div", {
                className: "absolute w-full h-full inset-0 opacity-20",
                style: {
                  backgroundColor: overlayBackgroundColor
                }
              }) : null
          ],
          className: "w-full h-full group relative",
          onMouseDown: param => {
            applyBrush(i, j);
            setCursorOverlayOff(param => true);
          },
          onMouseEnter: param => {
            setHoveredCell(param => [
              i,
              j
            ]);
            if (isMouseDown) {
              return applyBrush(i, j);
            }
            
          },
          onMouseLeave: param => setHoveredCell(param => {})
        }, i.toString() + j.toString());
      })),
      className: "absolute top-0 left-0",
      style: {
        backgroundColor: props.canvasBackgroundColor,
        display: "grid",
        gridTemplateColumns: "repeat(" + props.boardDimI.toString() + ", 1rem)",
        gridTemplateRows: "repeat(" + props.boardDimJ.toString() + ", 1rem)",
        transform: props.transformValue,
        transformOrigin: "top left"
      }
    }),
    ref: Primitive_option.some(props.canvasContainerRef),
    className: "relative border border-gray-300 overflow-hidden",
    style: {
      backgroundColor: props.viewportBackgroundColor,
      height: "384px",
      width: "384px"
    }
  });
}

function App$CanvasThumbnails(props) {
  let onSelectCanvas = props.onSelectCanvas;
  let handleAddCanvas = props.handleAddCanvas;
  let handleDeleteCanvas = props.handleDeleteCanvas;
  let canDeleteCanvas = props.canDeleteCanvas;
  let currentCanvasIndex = props.currentCanvasIndex;
  return JsxRuntime.jsxs("div", {
    children: [
      props.canvases.map((canvasBoard, canvasIndex) => {
        let match = dims2D(canvasBoard);
        let isSelectedCanvas = canvasIndex === currentCanvasIndex;
        return JsxRuntime.jsxs("div", {
          children: [
            JsxRuntime.jsx("button", {
              children: JsxRuntime.jsx("div", {
                children: canvasBoard.map((line, i) => line.map((cell, j) => JsxRuntime.jsx("div", {
                  className: "w-full h-full",
                  style: {
                    backgroundColor: Stdlib_Nullable.getOr(cell, "transparent")
                  }
                }, i.toString() + j.toString()))),
                className: "h-16 w-16 grid",
                style: {
                  gridTemplateColumns: "repeat(" + match[0].toString() + ", minmax(0, 1fr))",
                  gridTemplateRows: "repeat(" + match[1].toString() + ", minmax(0, 1fr))"
                }
              }),
              className: [" w-fit h-fit"].join(" "),
              onClick: param => onSelectCanvas(canvasIndex)
            }),
            isSelectedCanvas ? JsxRuntime.jsx("button", {
                children: "x",
                className: [
                  " w-4 h-4 leading-none text-sm font-medium absolute right-0 bottom-0",
                  canDeleteCanvas ? "bg-red-500 text-white" : "bg-gray-200 text-gray-500 cursor-not-allowed"
                ].join(" "),
                disabled: !canDeleteCanvas,
                onClick: e => {
                  e.stopPropagation();
                  handleDeleteCanvas();
                }
              }) : null
          ],
          className: [
            "relative flex-shrink-0 border w-fit h-fit",
            isSelectedCanvas ? "border-blue-500" : "border-gray-200"
          ].join(" ")
        }, canvasIndex.toString());
      }),
      JsxRuntime.jsx("button", {
        children: "+",
        className: "flex-shrink-0 h-16 w-16 border-2 border-dashed border-gray-300 flex items-center justify-center text-3xl text-gray-400",
        onClick: param => handleAddCanvas()
      })
    ],
    className: "flex flex-row items-start gap-3 overflow-x-auto"
  });
}

function App$CanvasColorsControl(props) {
  let setViewportBackgroundColor = props.setViewportBackgroundColor;
  let setCanvasBackgroundColor = props.setCanvasBackgroundColor;
  let myColor = props.myColor;
  return JsxRuntime.jsxs("div", {
    children: [
      JsxRuntime.jsxs("div", {
        children: [
          JsxRuntime.jsx("span", {
            children: "Canvas Colors",
            className: "font-medium flex-1"
          }),
          JsxRuntime.jsx("button", {
            children: "Default",
            className: "flex flex-row items-center gap-1 text-xs font-medium ml-2",
            type: "button",
            onClick: param => {
              setCanvasBackgroundColor(param => canvasBackgroundColor);
              setViewportBackgroundColor(param => viewportBackgroundColor);
            }
          })
        ],
        className: "flex flex-row"
      }),
      JsxRuntime.jsxs("div", {
        children: [
          JsxRuntime.jsxs("button", {
            children: [
              JsxRuntime.jsx("div", {
                children: "Background",
                className: "flex-1 text-left"
              }),
              JsxRuntime.jsx("div", {
                className: "w-6 h-6 border rounded",
                style: {
                  backgroundColor: props.canvasBackgroundColor
                }
              })
            ],
            className: "flex flex-row items-center gap-1 text-xs font-medium ",
            type: "button",
            onClick: param => setCanvasBackgroundColor(param => myColor)
          }),
          JsxRuntime.jsxs("button", {
            children: [
              JsxRuntime.jsx("div", {
                children: "Viewport",
                className: "flex-1 text-left"
              }),
              JsxRuntime.jsx("div", {
                className: "w-6 h-6 border rounded",
                style: {
                  backgroundColor: props.viewportBackgroundColor
                }
              })
            ],
            className: "flex flex-row items-center gap-1 text-xs font-medium",
            type: "button",
            onClick: param => setViewportBackgroundColor(param => myColor)
          })
        ],
        className: "flex flex-col gap-1"
      })
    ],
    className: "border rounded p-2 flex flex-col gap-2 w-full"
  });
}

function App$ColorControl(props) {
  let setMyColor = props.setMyColor;
  let setBrushMode = props.setBrushMode;
  let brushMode = props.brushMode;
  return JsxRuntime.jsxs("div", {
    children: [
      JsxRuntime.jsxs("div", {
        children: [
          JsxRuntime.jsx("button", {
            children: "Color",
            className: [
              brushMode === "Color" ? " bg-blue-500 text-white" : "bg-gray-200",
              "px-2 font-medium rounded"
            ].join(" "),
            onClick: param => setBrushMode(param => "Color")
          }),
          JsxRuntime.jsx("button", {
            children: "Erase",
            className: [
              brushMode === "Erase" ? " bg-blue-500 text-white" : "bg-gray-200",
              "px-2 font-medium rounded"
            ].join(" "),
            onClick: param => setBrushMode(param => "Erase")
          })
        ],
        className: "flex flex-row gap-2"
      }),
      JsxRuntime.jsx(ReactColorful.HexColorPicker, {
        color: props.myColor,
        onChange: newColor => setMyColor(param => newColor)
      })
    ],
    className: "flex flex-col gap-2"
  });
}

function App$BrushOverlayControl(props) {
  let setShowCursorOverlay = props.setShowCursorOverlay;
  return JsxRuntime.jsxs("div", {
    children: [
      JsxRuntime.jsx("div", {
        children: "Brush Overlay",
        className: "flex flex-row font-medium"
      }),
      JsxRuntime.jsx(make, {
        checked: props.showCursorOverlay,
        onChange: v => setShowCursorOverlay(param => v)
      })
    ],
    className: "flex flex-row justify-between border rounded p-2 w-full"
  });
}

function App$CanvasSizeControl(props) {
  let onSubmitResize = props.onSubmitResize;
  let canSubmitResize = props.canSubmitResize;
  let setResizeColsInput = props.setResizeColsInput;
  let setResizeRowsInput = props.setResizeRowsInput;
  let setIsResizeOpen = props.setIsResizeOpen;
  let isResizeOpen = props.isResizeOpen;
  return JsxRuntime.jsxs("div", {
    children: [
      JsxRuntime.jsxs("button", {
        children: [
          "Canvas Size",
          JsxRuntime.jsx("span", {
            children: isResizeOpen ? "-" : "+"
          })
        ],
        className: [
          "flex flex-row items-center justify-between font-medium",
          "w-full"
        ].join(" "),
        onClick: param => setIsResizeOpen(v => !v)
      }),
      isResizeOpen ? JsxRuntime.jsxs("div", {
          children: [
            JsxRuntime.jsxs("div", {
              children: [
                JsxRuntime.jsx("input", {
                  className: "border rounded px-2 py-1 text-sm flex-1 min-w-0",
                  value: props.resizeRowsInput,
                  onChange: event => {
                    let value = event.target.value;
                    setResizeRowsInput(param => value);
                  }
                }),
                JsxRuntime.jsx("span", {
                  children: "x",
                  className: "flex-none px-1"
                }),
                JsxRuntime.jsx("input", {
                  className: "border rounded px-2 py-1 text-sm flex-1  min-w-0",
                  value: props.resizeColsInput,
                  onChange: event => {
                    let value = event.target.value;
                    setResizeColsInput(param => value);
                  }
                })
              ],
              className: "flex flex-row w-full gap-2"
            }),
            JsxRuntime.jsx("button", {
              children: "Save",
              className: [
                "rounded px-2 py-1 text-sm font-medium",
                canSubmitResize ? "bg-blue-500 text-white" : "bg-gray-200 text-gray-500 cursor-not-allowed"
              ].join(" "),
              disabled: !canSubmitResize,
              onClick: param => onSubmitResize()
            })
          ],
          className: "flex flex-col gap-2"
        }) : null
    ],
    className: "border rounded p-2 flex flex-col gap-2 w-full"
  });
}

function App$ZoomControl(props) {
  let onCenterCanvas = props.onCenterCanvas;
  let onZoomIn = props.onZoomIn;
  let onZoomReset = props.onZoomReset;
  let onZoomOut = props.onZoomOut;
  let zoomPercentString = (props.zoom * 100).toFixed(0);
  return JsxRuntime.jsxs("div", {
    children: [
      JsxRuntime.jsxs("div", {
        children: [
          JsxRuntime.jsx("span", {
            children: "Zoom",
            className: "font-medium"
          }),
          JsxRuntime.jsx("span", {
            children: zoomPercentString + "%",
            className: "text-sm font-mono"
          })
        ],
        className: "flex flex-row items-center justify-between"
      }),
      JsxRuntime.jsxs("div", {
        children: [
          JsxRuntime.jsx("button", {
            children: "-",
            className: "flex-1 rounded px-2 py-1 text-sm font-medium bg-gray-200",
            onClick: param => onZoomOut()
          }),
          JsxRuntime.jsx("button", {
            children: "100%",
            className: "flex-1 rounded px-2 py-1 text-sm font-medium bg-gray-200",
            onClick: param => onZoomReset()
          }),
          JsxRuntime.jsx("button", {
            children: "+",
            className: "flex-1 rounded px-2 py-1 text-sm font-medium bg-gray-200",
            onClick: param => onZoomIn()
          })
        ],
        className: "flex flex-row gap-2"
      }),
      JsxRuntime.jsx("button", {
        children: "Center",
        className: "rounded px-2 py-1 text-sm font-medium bg-gray-200",
        onClick: param => onCenterCanvas()
      })
    ],
    className: "border rounded p-2 flex flex-col gap-2 w-full"
  });
}

function App$SilhouetteControl(props) {
  let setIsSilhouette = props.setIsSilhouette;
  return JsxRuntime.jsxs("div", {
    children: [
      JsxRuntime.jsx("div", {
        children: "Silhouette",
        className: "font-medium"
      }),
      JsxRuntime.jsx(make, {
        checked: props.isSilhouette,
        onChange: value => setIsSilhouette(param => value)
      })
    ],
    className: "flex flex-row items-center justify-between border rounded p-2 w-full"
  });
}

function App$ExportControl(props) {
  let onExport = props.onExport;
  let canExport = props.canExport;
  let setIncludeBackground = props.setIncludeBackground;
  let setExportScaleInput = props.setExportScaleInput;
  return JsxRuntime.jsxs("div", {
    children: [
      JsxRuntime.jsx("span", {
        children: "Export PNG",
        className: "font-medium"
      }),
      JsxRuntime.jsxs("div", {
        children: [
          JsxRuntime.jsxs("label", {
            children: [
              JsxRuntime.jsx("span", {
                children: "Scale",
                className: "text-xs uppercase tracking-wide text-gray-500"
              }),
              JsxRuntime.jsx("input", {
                className: "border rounded px-2 py-1 text-sm w-16",
                min: "1",
                step: 1.0,
                type: "number",
                value: props.exportScaleInput,
                onChange: event => {
                  let value = event.target.value;
                  setExportScaleInput(param => value);
                }
              })
            ],
            className: "flex flex-col gap-1 text-sm"
          }),
          JsxRuntime.jsx("button", {
            children: "Export",
            className: [
              "rounded px-2 py-1 text-sm font-medium flex-1 h-fit",
              canExport ? "bg-blue-500 text-white" : "bg-gray-200 text-gray-500 cursor-not-allowed"
            ].join(" "),
            disabled: !canExport,
            onClick: param => onExport()
          })
        ],
        className: "flex flex-row  gap-2 items-end"
      }),
      JsxRuntime.jsxs("label", {
        children: [
          JsxRuntime.jsx("input", {
            checked: props.includeBackground,
            type: "checkbox",
            onChange: event => {
              let checked = event.target.checked;
              setIncludeBackground(param => checked);
            }
          }),
          JsxRuntime.jsx("span", {
            children: "Include Background"
          })
        ],
        className: "flex flex-row items-center gap-2 text-sm"
      })
    ],
    className: "border rounded p-2 flex flex-col gap-2 w-full"
  });
}

function App$ControlsPanel(props) {
  let myColor = props.myColor;
  return JsxRuntime.jsxs("div", {
    children: [
      JsxRuntime.jsx(App$ColorControl, {
        brushMode: props.brushMode,
        setBrushMode: props.setBrushMode,
        myColor: myColor,
        setMyColor: props.setMyColor
      }),
      JsxRuntime.jsx(App$CanvasColorsControl, {
        myColor: myColor,
        canvasBackgroundColor: props.canvasBackgroundColor,
        setCanvasBackgroundColor: props.setCanvasBackgroundColor,
        viewportBackgroundColor: props.viewportBackgroundColor,
        setViewportBackgroundColor: props.setViewportBackgroundColor
      }),
      JsxRuntime.jsx(App$ZoomControl, {
        onZoomOut: props.onZoomOut,
        onZoomReset: props.onZoomReset,
        onZoomIn: props.onZoomIn,
        onCenterCanvas: props.onCenterCanvas,
        zoom: props.zoom
      }),
      JsxRuntime.jsx(App$SilhouetteControl, {
        isSilhouette: props.isSilhouette,
        setIsSilhouette: props.setIsSilhouette
      }),
      JsxRuntime.jsx(App$ExportControl, {
        exportScaleInput: props.exportScaleInput,
        setExportScaleInput: props.setExportScaleInput,
        includeBackground: props.includeExportBackground,
        setIncludeBackground: props.setIncludeExportBackground,
        canExport: props.canExport,
        onExport: props.onExport
      }),
      JsxRuntime.jsx(App$CanvasSizeControl, {
        isResizeOpen: props.isResizeOpen,
        setIsResizeOpen: props.setIsResizeOpen,
        resizeRowsInput: props.resizeRowsInput,
        setResizeRowsInput: props.setResizeRowsInput,
        resizeColsInput: props.resizeColsInput,
        setResizeColsInput: props.setResizeColsInput,
        canSubmitResize: props.canSubmitResize,
        onSubmitResize: props.onSubmitResize
      }),
      JsxRuntime.jsx(App$BrushOverlayControl, {
        showCursorOverlay: props.showCursorOverlay,
        setShowCursorOverlay: props.setShowCursorOverlay
      })
    ],
    className: "flex flex-col gap-2 flex-none width-48 h-full overflow-y-scroll"
  });
}

function App(props) {
  let match = UseLocalStorageJs("brush-mode", "Color");
  let brushMode = match[0];
  let match$1 = UseLocalStorageJs("canvases", [make2D(12, 12, () => null)]);
  let setCanvases = match$1[1];
  let canvases = match$1[0];
  let match$2 = UseLocalStorageJs("selected-canvas-index", 0);
  let setSelectedCanvasIndex = match$2[1];
  let selectedCanvasIndex = match$2[0];
  let match$3 = UseLocalStorageJs("brush", make2D(3, 3, () => true));
  let brush = match$3[0];
  let match$4 = UseLocalStorageJs("saved-brushes", defaultBrushes);
  let setSavedBrushes = match$4[1];
  let savedBrushes = match$4[0];
  let match$5 = UseLocalStorageJs("saved-tile-masks", defaultTileMasks);
  let setSavedTileMasks = match$5[1];
  let savedTileMasks = match$5[0];
  let match$6 = UseLocalStorageJs("selected-tile-mask-index", 0);
  let setSelectedTileMaskIndex = match$6[1];
  let selectedTileMaskIndex = match$6[0];
  let match$7 = UseLocalStorageJs("tile-mask", make2D(4, 4, () => true));
  let setTileMask = match$7[1];
  let tileMask = match$7[0];
  let match$8 = UseLocalStorageJs("show-cursor-overlay", true);
  let showCursorOverlay = match$8[0];
  let match$9 = UseLocalStorageJs("my-color", "blue");
  let myColor = match$9[0];
  let match$10 = UseLocalStorageJs("canvas-background-color", canvasBackgroundColor);
  let canvasBackgroundColor$1 = match$10[0];
  let match$11 = UseLocalStorageJs("viewport-background-color", viewportBackgroundColor);
  let viewportBackgroundColor$1 = match$11[0];
  let match$12 = UseLocalStorageJs("canvas-silhouette", false);
  let isSilhouette = match$12[0];
  let match$13 = React.useState(() => false);
  let setCursorOverlayOff = match$13[1];
  let match$14 = React.useState(() => {});
  let setHoveredCell = match$14[1];
  let match$15 = React.useState(() => "1");
  let exportScaleInput = match$15[0];
  let match$16 = React.useState(() => true);
  let includeExportBackground = match$16[0];
  let match$17 = UseLocalStorageJs("canvas-zoom", 1);
  let setZoom = match$17[1];
  let zoom = match$17[0];
  let zoomRef = React.useRef(zoom);
  zoomRef.current = zoom;
  let canvasContainerRef = React.useRef(null);
  let match$18 = React.useState(() => [
    192,
    192
  ]);
  let setViewportCenter = match$18[1];
  let viewportCenter = match$18[0];
  let updateViewportCenter = () => {
    let element = canvasContainerRef.current;
    if (element == null) {
      return;
    }
    let rect = element.getBoundingClientRect();
    setViewportCenter(param => [
      rect.width / 2,
      rect.height / 2
    ]);
  };
  React.useEffect(() => {
    updateViewportCenter();
    let handleResize = param => updateViewportCenter();
    window.addEventListener("resize", handleResize);
    return () => {
      window.removeEventListener("resize", handleResize);
    };
  }, []);
  let clampZoom = value => {
    let cappedMax = value > 4 ? 4 : value;
    if (cappedMax < 0.25) {
      return 0.25;
    } else {
      return cappedMax;
    }
  };
  let match$19 = UseLocalStorageJs("canvas-pan", [
    0,
    0
  ]);
  let setPan = match$19[1];
  let pan = match$19[0];
  let panRef = React.useRef(pan);
  panRef.current = pan;
  let adjustPan = (deltaX, deltaY) => setPan(param => [
    param[0] + deltaX,
    param[1] + deltaY
  ]);
  let updateZoom = updater => setZoom(prev => {
    let next = clampZoom(updater(prev));
    if (next !== prev) {
      let centerY = viewportCenter[1];
      let centerX = viewportCenter[0];
      let match = panRef.current;
      let boardCenterX = (centerX - match[0]) / prev;
      let boardCenterY = (centerY - match[1]) / prev;
      let nextPanX = centerX - boardCenterX * next;
      let nextPanY = centerY - boardCenterY * next;
      setPan(param => [
        nextPanX,
        nextPanY
      ]);
    }
    return next;
  });
  let resetZoom = () => updateZoom(param => 1);
  let zoomIn = () => updateZoom(prev => prev * 1.1);
  let zoomOut = () => {
    let factor = 1 / 1.1;
    updateZoom(prev => prev * factor);
  };
  let isMouseDown = useIsMouseDown();
  let canvasCount = canvases.length;
  React.useEffect(() => {
    if (canvasCount === 0) {
      setCanvases(param => [make2D(12, 12, () => null)]);
    }
    
  }, []);
  React.useEffect(() => {
    if (canvasCount > 0 && selectedCanvasIndex >= canvasCount) {
      setSelectedCanvasIndex(param => canvasCount - 1 | 0);
    }
    
  }, []);
  let currentCanvasIndex = canvasCount === 0 ? 0 : (
      selectedCanvasIndex >= canvasCount ? canvasCount - 1 | 0 : selectedCanvasIndex
    );
  let canvas = canvases[currentCanvasIndex];
  let board = canvas !== undefined ? canvas : Stdlib_Option.getOr(canvases[0], make2D(12, 12, () => null));
  let updateCanvasAtIndex = (index, updater) => setCanvases(prev => {
    if (prev.length === 0) {
      return [updater(make2D(12, 12, () => null))];
    } else {
      return prev.map((canvas, idx) => {
        if (idx === index) {
          return updater(canvas);
        } else {
          return canvas;
        }
      });
    }
  });
  let match$20 = dims2D(board);
  let boardDimJ = match$20[1];
  let boardDimI = match$20[0];
  let match$21 = dims2D(brush);
  let brushCenterDimI = match$21[0] / 2 | 0;
  let brushCenterDimJ = match$21[1] / 2 | 0;
  let match$22 = dims2D(tileMask);
  let tileMaskDimJ = match$22[1];
  let tileMaskDimI = match$22[0];
  let centerCanvas = () => {
    let boardWidth = boardDimI * 16;
    let boardHeight = boardDimJ * 16;
    let currentZoom = zoomRef.current;
    let nextPanX = viewportCenter[0] - boardWidth * currentZoom / 2;
    let nextPanY = viewportCenter[1] - boardHeight * currentZoom / 2;
    setPan(param => [
      nextPanX,
      nextPanY
    ]);
  };
  let match$23 = React.useState(() => false);
  let setIsResizeOpen = match$23[1];
  let match$24 = React.useState(() => boardDimI.toString());
  let setResizeRowsInput = match$24[1];
  let resizeRowsInput = match$24[0];
  let match$25 = React.useState(() => boardDimJ.toString());
  let setResizeColsInput = match$25[1];
  let resizeColsInput = match$25[0];
  React.useEffect(() => {
    setResizeRowsInput(param => boardDimI.toString());
    setResizeColsInput(param => boardDimJ.toString());
  }, [
    boardDimI,
    boardDimJ
  ]);
  React.useEffect(() => {
    let mask = savedTileMasks[selectedTileMaskIndex];
    if (mask !== undefined) {
      if (!OtherJs.isEqual2D(mask, tileMask)) {
        setTileMask(param => mask);
      }
      return;
    }
    if (savedTileMasks.length > 0) {
      let fallbackIndex = selectedTileMaskIndex >= savedTileMasks.length ? savedTileMasks.length - 1 | 0 : 0;
      setSelectedTileMaskIndex(param => fallbackIndex);
    }
    
  }, [
    savedTileMasks,
    selectedTileMaskIndex
  ]);
  let parsePositiveInt = value => {
    let parsed = Stdlib_Int.fromString(value, undefined);
    if (parsed !== undefined && parsed > 0) {
      return parsed;
    }
    
  };
  let parsePositiveFloat = value => {
    let parsed = Belt_Float.fromString(value);
    if (parsed !== undefined && parsed > 0) {
      return parsed;
    }
    
  };
  let match$26 = parsePositiveInt(resizeRowsInput);
  let match$27 = parsePositiveInt(resizeColsInput);
  let canSubmitResize = match$26 !== undefined && match$27 !== undefined ? match$26 !== boardDimI || match$27 !== boardDimJ : false;
  let exportScaleValue = parsePositiveFloat(exportScaleInput);
  let canExport = Stdlib_Option.isSome(exportScaleValue);
  let handleResizeSubmit = () => {
    let match = parsePositiveInt(resizeRowsInput);
    let match$1 = parsePositiveInt(resizeColsInput);
    if (match !== undefined && match$1 !== undefined) {
      updateCanvasAtIndex(currentCanvasIndex, prev => make2D(match, match$1, () => null).map((row, rowI) => row.map((param, colJ) => Stdlib_Option.getOr(check2D(prev, rowI, colJ), null))));
      setHoveredCell(param => {});
      setCursorOverlayOff(param => true);
      return setIsResizeOpen(param => false);
    }
    
  };
  let handleExportPng = () => {
    if (exportScaleValue !== undefined) {
      let prim2 = {
        includeBackground: includeExportBackground,
        backgroundColor: canvasBackgroundColor$1
      };
      ExportBoardJs.exportBoardAsPng(board, exportScaleValue, prim2);
      return;
    }
    
  };
  let selectedSavedBrushIndex = Belt_Array.getIndexBy(savedBrushes, savedBrush => OtherJs.isEqual2D(savedBrush, brush));
  let canDeleteSelectedBrush = Stdlib_Option.isSome(selectedSavedBrushIndex);
  let canDeleteSelectedTileMask = savedTileMasks.length > 1;
  let handleDeleteSelectedBrush = () => {
    if (selectedSavedBrushIndex !== undefined) {
      return setSavedBrushes(prev => Belt_Array.keepWithIndex(prev, (param, idx) => idx !== selectedSavedBrushIndex));
    }
    
  };
  let handleDeleteSelectedTileMask = () => {
    if (canDeleteSelectedTileMask) {
      return setSavedTileMasks(prev => {
        let next = Belt_Array.keepWithIndex(prev, (param, idx) => idx !== selectedTileMaskIndex);
        let nextLength = next.length;
        let nextIndex = nextLength === 0 ? 0 : (
            selectedTileMaskIndex >= nextLength ? nextLength - 1 | 0 : selectedTileMaskIndex
          );
        setSelectedTileMaskIndex(param => nextIndex);
        let mask = next[nextIndex];
        if (mask !== undefined) {
          setTileMask(param => mask);
        }
        return next;
      });
    }
    
  };
  let canDeleteCanvas = canvasCount > 1;
  let handleAddCanvas = () => {
    let newCanvas = make2D(boardDimI, boardDimJ, () => null);
    setCanvases(prev => prev.concat([newCanvas]));
    setSelectedCanvasIndex(param => canvasCount);
    setHoveredCell(param => {});
    setCursorOverlayOff(param => true);
  };
  let handleDeleteCanvas = () => {
    if (!canDeleteCanvas) {
      return;
    }
    let nextSelected = selectedCanvasIndex >= (canvasCount - 1 | 0) ? (
        selectedCanvasIndex === 0 ? 0 : selectedCanvasIndex - 1 | 0
      ) : selectedCanvasIndex;
    setCanvases(prev => Belt_Array.keepWithIndex(prev, (_canvas, idx) => idx !== selectedCanvasIndex));
    setSelectedCanvasIndex(param => nextSelected);
    setHoveredCell(param => {});
    setCursorOverlayOff(param => true);
  };
  let handleSelectCanvas = canvasIndex => {
    setSelectedCanvasIndex(param => canvasIndex);
    setHoveredCell(param => {});
    setCursorOverlayOff(param => true);
  };
  let onMouseMove = param => setCursorOverlayOff(param => false);
  let canApply = (boardI, boardJ, clickI, clickJ) => {
    let brushPosI = (boardI - clickI | 0) + brushCenterDimI | 0;
    let brushPosJ = (boardJ - clickJ | 0) + brushCenterDimJ | 0;
    let brushAllows = Stdlib_Option.getOr(check2D(brush, brushPosI, brushPosJ), false);
    let maskAllows = Stdlib_Option.getOr(check2D(tileMask, Primitive_int.mod_(boardI, tileMaskDimI), Primitive_int.mod_(boardJ, tileMaskDimJ)), false);
    if (brushAllows) {
      return maskAllows;
    } else {
      return false;
    }
  };
  let getBrushColor = () => {
    if (brushMode === "Color") {
      return myColor;
    } else {
      return null;
    }
  };
  let applyBrush = (clickI, clickJ) => updateCanvasAtIndex(currentCanvasIndex, b => b.map((row, boardI) => row.map((cell, boardJ) => {
    if (canApply(boardI, boardJ, clickI, clickJ)) {
      return getBrushColor();
    } else {
      return cell;
    }
  })));
  React.useEffect(() => {
    window.addEventListener("mousemove", onMouseMove);
    return () => {
      window.removeEventListener("mousemove", onMouseMove);
    };
  }, []);
  React.useEffect(() => {
    let handleKeyDown = event => {
      if (event.metaKey) {
        let match = event.key;
        switch (match) {
          case "[" :
            event.preventDefault();
            let factor = 1 / 1.1;
            return updateZoom(prev => prev * factor);
          case "]" :
            event.preventDefault();
            return updateZoom(prev => prev * 1.1);
          default:
            return;
        }
      } else {
        let step = 16 / zoomRef.current;
        let match$1 = event.key;
        switch (match$1) {
          case "ArrowDown" :
            event.preventDefault();
            return adjustPan(0, step);
          case "ArrowLeft" :
            event.preventDefault();
            return adjustPan(- step, 0);
          case "ArrowRight" :
            event.preventDefault();
            return adjustPan(step, 0);
          case "ArrowUp" :
            event.preventDefault();
            return adjustPan(0, - step);
          default:
            return;
        }
      }
    };
    window.addEventListener("keydown", handleKeyDown);
    return () => {
      window.removeEventListener("keydown", handleKeyDown);
    };
  }, []);
  let offsetXString = pan[0].toString();
  let offsetYString = pan[1].toString();
  let zoomString = zoom.toString();
  let transformValue = "translate3d(" + offsetXString + "px, " + offsetYString + "px, 0) scale(" + zoomString + ")";
  return JsxRuntime.jsxs("div", {
    children: [
      JsxRuntime.jsxs("div", {
        children: [
          JsxRuntime.jsx(App$SavedBrushesPanel, {
            board: board,
            brush: brush,
            setBrush: match$3[1],
            savedBrushes: savedBrushes,
            setSavedBrushes: setSavedBrushes,
            canDeleteSelectedBrush: canDeleteSelectedBrush,
            handleDeleteSelectedBrush: handleDeleteSelectedBrush
          }),
          JsxRuntime.jsx(App$SavedTileMasksPanel, {
            board: board,
            setTileMask: setTileMask,
            savedTileMasks: savedTileMasks,
            setSavedTileMasks: setSavedTileMasks,
            selectedTileMaskIndex: selectedTileMaskIndex,
            setSelectedTileMaskIndex: setSelectedTileMaskIndex,
            canDeleteSelectedTileMask: canDeleteSelectedTileMask,
            handleDeleteSelectedTileMask: handleDeleteSelectedTileMask
          })
        ],
        className: "flex flex-row gap-2 h-full p-2 border rounded flex-none"
      }),
      JsxRuntime.jsxs("div", {
        children: [
          JsxRuntime.jsx(App$CanvasViewport, {
            canvasContainerRef: canvasContainerRef,
            board: board,
            boardDimI: boardDimI,
            boardDimJ: boardDimJ,
            transformValue: transformValue,
            hoveredCell: match$14[0],
            setHoveredCell: setHoveredCell,
            cursorOverlayOff: match$13[0],
            setCursorOverlayOff: setCursorOverlayOff,
            isMouseDown: isMouseDown,
            applyBrush: applyBrush,
            canApply: canApply,
            showCursorOverlay: showCursorOverlay,
            canvasBackgroundColor: canvasBackgroundColor$1,
            viewportBackgroundColor: viewportBackgroundColor$1,
            isSilhouette: isSilhouette
          }),
          JsxRuntime.jsx("div", {
            children: JsxRuntime.jsx(App$CanvasThumbnails, {
              canvases: canvases,
              currentCanvasIndex: currentCanvasIndex,
              canDeleteCanvas: canDeleteCanvas,
              handleDeleteCanvas: handleDeleteCanvas,
              handleAddCanvas: handleAddCanvas,
              onSelectCanvas: handleSelectCanvas
            }),
            className: "flex flex-col gap-2 w-full"
          })
        ],
        className: "flex flex-col gap-2 flex-1"
      }),
      JsxRuntime.jsx(App$ControlsPanel, {
        brushMode: brushMode,
        setBrushMode: match[1],
        myColor: myColor,
        setMyColor: match$9[1],
        canvasBackgroundColor: canvasBackgroundColor$1,
        setCanvasBackgroundColor: match$10[1],
        viewportBackgroundColor: viewportBackgroundColor$1,
        setViewportBackgroundColor: match$11[1],
        isSilhouette: isSilhouette,
        setIsSilhouette: match$12[1],
        showCursorOverlay: showCursorOverlay,
        setShowCursorOverlay: match$8[1],
        isResizeOpen: match$23[0],
        setIsResizeOpen: setIsResizeOpen,
        resizeRowsInput: resizeRowsInput,
        setResizeRowsInput: setResizeRowsInput,
        resizeColsInput: resizeColsInput,
        setResizeColsInput: setResizeColsInput,
        canSubmitResize: canSubmitResize,
        onSubmitResize: handleResizeSubmit,
        zoom: zoom,
        onZoomIn: zoomIn,
        onZoomOut: zoomOut,
        onZoomReset: resetZoom,
        onCenterCanvas: centerCanvas,
        exportScaleInput: exportScaleInput,
        setExportScaleInput: match$15[1],
        includeExportBackground: includeExportBackground,
        setIncludeExportBackground: match$16[1],
        canExport: canExport,
        onExport: handleExportPng
      })
    ],
    className: " flex flex-row gap-5 p-3 h-dvh"
  });
}

let make$1 = App;

export {
  make$1 as make,
}
/* make Not a pure module */
