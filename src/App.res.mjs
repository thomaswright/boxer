// Generated by ReScript, PLEASE EDIT WITH CARE

import * as Board from "./Board.res.mjs";
import * as React from "react";
import * as Array2D from "./Array2D.res.mjs";
import * as Initials from "./Initials.res.mjs";
import * as Belt_Array from "rescript/lib/es6/Belt_Array.js";
import * as Belt_Float from "rescript/lib/es6/Belt_Float.js";
import * as ColorsUsed from "./ColorsUsed.res.mjs";
import * as Js_promise from "rescript/lib/es6/Js_promise.js";
import * as Stdlib_Int from "rescript/lib/es6/Stdlib_Int.js";
import * as Belt_Option from "rescript/lib/es6/Belt_Option.js";
import * as ZoomControl from "./ZoomControl.res.mjs";
import * as Color from "@texel/color";
import * as ColorControl from "./ColorControl.res.mjs";
import * as ExportControl from "./ExportControl.res.mjs";
import * as Primitive_int from "rescript/lib/es6/Primitive_int.js";
import * as Stdlib_Option from "rescript/lib/es6/Stdlib_Option.js";
import * as CanvasViewport from "./CanvasViewport.res.mjs";
import * as DotModeControl from "./DotModeControl.res.mjs";
import * as ExportBoardJs from "./exportBoard.js";
import * as CanvasThumbnails from "./CanvasThumbnails.res.mjs";
import * as BoardStorageJs from "./boardStorage.js";
import * as CanvasGridControl from "./CanvasGridControl.res.mjs";
import * as CanvasSizeControl from "./CanvasSizeControl.res.mjs";
import * as SavedBrushesPanel from "./SavedBrushesPanel.res.mjs";
import * as SilhouetteControl from "./SilhouetteControl.res.mjs";
import * as JsxRuntime from "react/jsx-runtime";
import * as BrushOverlayControl from "./BrushOverlayControl.res.mjs";
import * as CanvasColorsControl from "./CanvasColorsControl.res.mjs";
import * as SavedTileMasksPanel from "./SavedTileMasksPanel.res.mjs";
import UseLocalStorageJs from "./useLocalStorage.js";
import * as UseLocalStorageJs$1 from "./useLocalStorage.js";

function generateCanvasId() {
  let timestamp = Date.now().toString();
  let random = Math.random().toString();
  return timestamp + "-" + random;
}

function makeCanvas(zoom, pan, isDotMaskOpt, canvasBackgroundColorOpt) {
  let isDotMask = isDotMaskOpt !== undefined ? isDotMaskOpt : false;
  let canvasBackgroundColor = canvasBackgroundColorOpt !== undefined ? canvasBackgroundColorOpt : Initials.canvasBackgroundColor;
  return {
    id: generateCanvasId(),
    zoom: zoom,
    pan: pan,
    isDotMask: isDotMask,
    canvasBackgroundColor: canvasBackgroundColor
  };
}

function useIsMouseDown() {
  let match = React.useState(() => false);
  let setIsMouseDown = match[1];
  React.useEffect(() => {
    let downHandler = param => {
      setIsMouseDown(param => true);
      UseLocalStorageJs$1.setLocalStoragePersistencePaused(true);
    };
    let upHandler = param => {
      setIsMouseDown(param => false);
      UseLocalStorageJs$1.setLocalStoragePersistencePaused(false);
    };
    window.addEventListener("mousedown", downHandler);
    window.addEventListener("mouseup", upHandler);
    return () => {
      window.removeEventListener("mousedown", downHandler);
      window.removeEventListener("mouseup", upHandler);
      UseLocalStorageJs$1.setLocalStoragePersistencePaused(false);
    };
  }, []);
  return match[0];
}

function _isLight(color) {
  let match = Color.convert(Color.hexToRGB(color), Color.sRGB, Color.OKHSL);
  return match[2] > 0.5;
}

let defaultTileMaskPatterns = [
  [[true]],
  [
    [
      true,
      false
    ],
    [
      false,
      true
    ]
  ],
  [
    [
      false,
      true
    ],
    [
      true,
      false
    ]
  ],
  [
    [
      false,
      true
    ],
    [
      false,
      true
    ]
  ],
  [
    [
      true,
      false
    ],
    [
      true,
      false
    ]
  ],
  [
    [
      false,
      false
    ],
    [
      true,
      true
    ]
  ],
  [
    [
      true,
      true
    ],
    [
      false,
      false
    ]
  ],
  [
    [
      true,
      false,
      false
    ],
    [
      false,
      true,
      false
    ],
    [
      false,
      false,
      true
    ]
  ]
];

let defaultTileMaskEntries = defaultTileMaskPatterns.map((mask, index) => ({
  id: "default-tile-mask-" + index.toString(),
  mask: mask
}));

let defaultBrushPatterns = [
  Array2D.make(1, 1, () => true),
  Array2D.make(2, 2, () => true),
  Array2D.make(3, 3, () => true),
  Array2D.make(4, 4, () => true),
  Array2D.make(8, 8, () => true),
  Array2D.make(12, 12, () => true),
  Array2D.make(16, 16, () => true)
];

let defaultBrushEntries = defaultBrushPatterns.map((brush, index) => ({
  id: "default-brush-" + index.toString(),
  brush: brush
}));

function App(props) {
  let canvasContainerRef = React.useRef(null);
  let match = React.useState(() => [
    192,
    192
  ]);
  let setViewportCenter = match[1];
  let viewportCenter = match[0];
  let viewportCenterRef = React.useRef(viewportCenter);
  viewportCenterRef.current = viewportCenter;
  let updateViewportCenter = () => {
    let element = canvasContainerRef.current;
    if (element == null) {
      return;
    }
    let rect = element.getBoundingClientRect();
    let nextCenter_0 = rect.width / 2;
    let nextCenter_1 = rect.height / 2;
    let nextCenter = [
      nextCenter_0,
      nextCenter_1
    ];
    viewportCenterRef.current = nextCenter;
    setViewportCenter(param => nextCenter);
  };
  React.useEffect(() => {
    updateViewportCenter();
    let handleResize = param => updateViewportCenter();
    window.addEventListener("resize", handleResize);
    return () => {
      window.removeEventListener("resize", handleResize);
    };
  }, []);
  let clampZoom = value => {
    let cappedMax = value > Initials.maxZoomIn ? Initials.maxZoomIn : value;
    if (cappedMax < Initials.maxZoomOut) {
      return Initials.maxZoomOut;
    } else {
      return cappedMax;
    }
  };
  let computeCenteredPan = (dimI, dimJ, zoomValue) => {
    let match = viewportCenterRef.current;
    let boardWidth = dimJ * 1;
    let boardHeight = dimI * 1;
    let nextPanX = match[0] - boardWidth * zoomValue / 2;
    let nextPanY = match[1] - boardHeight * zoomValue / 2;
    return [
      nextPanX,
      nextPanY
    ];
  };
  let computeZoomToFitForDimensions = (dimI, dimJ) => {
    let containerElement = canvasContainerRef.current;
    if (containerElement == null) {
      return;
    }
    let rect = containerElement.getBoundingClientRect();
    let viewportWidth = rect.width;
    let viewportHeight = rect.height;
    let boardWidth = dimJ * 1;
    let boardHeight = dimI * 1;
    if (viewportWidth <= 0 || viewportHeight <= 0 || boardWidth <= 0 || boardHeight <= 0) {
      return;
    }
    let zoomByWidth = viewportWidth / boardWidth;
    let zoomByHeight = viewportHeight / boardHeight;
    let zoomToFit = zoomByWidth < zoomByHeight ? zoomByWidth : zoomByHeight;
    return clampZoom(zoomToFit);
  };
  let computeFitViewForDimensions = (dimI, dimJ) => {
    let fallbackPan = computeCenteredPan(dimI, dimJ, 1);
    let nextZoom = computeZoomToFitForDimensions(dimI, dimJ);
    if (nextZoom === undefined) {
      return [
        1,
        fallbackPan
      ];
    }
    let nextPan = computeCenteredPan(dimI, dimJ, nextZoom);
    return [
      nextZoom,
      nextPan
    ];
  };
  let makeDefaultCanvas = () => {
    let defaultBoard = Board.make(12, 12);
    let match = computeFitViewForDimensions(12, 12);
    return [
      makeCanvas(match[0], match[1], false, undefined),
      defaultBoard
    ];
  };
  let match$1 = UseLocalStorageJs("canvas-metadata-v1", []);
  let setCanvases = match$1[1];
  let canvases = match$1[0];
  let match$2 = React.useState(() => []);
  let setCanvasBoards = match$2[1];
  let canvasBoards = match$2[0];
  let match$3 = UseLocalStorageJs("saved-brushes", defaultBrushEntries);
  let setSavedBrushes = match$3[1];
  let savedBrushes = match$3[0];
  let match$4 = UseLocalStorageJs("saved-tile-masks", defaultTileMaskEntries);
  let setSavedTileMasks = match$4[1];
  let savedTileMasks = match$4[0];
  let match$5 = UseLocalStorageJs("viewport-background-color", Initials.viewportBackgroundColor);
  let viewportBackgroundColor = match$5[0];
  let match$6 = React.useState(() => false);
  let setBoardsLoaded = match$6[1];
  let areBoardsLoaded = match$6[0];
  let match$7 = UseLocalStorageJs("selected-brush-id", undefined);
  let setSelectedBrushId = match$7[1];
  let selectedBrushId = match$7[0];
  let match$8 = UseLocalStorageJs("selected-tile-mask-id", undefined);
  let setSelectedTileMaskId = match$8[1];
  let selectedTileMaskId = match$8[0];
  let match$9 = UseLocalStorageJs("selected-canvas-id", undefined);
  let setSelectedCanvasId = match$9[1];
  let selectedCanvasId = match$9[0];
  let match$10 = UseLocalStorageJs("my-color", Initials.myColor);
  let setMyColor = match$10[1];
  let myColor = match$10[0];
  let match$11 = UseLocalStorageJs("brush-mode", "Color");
  let setBrushMode = match$11[1];
  let brushMode = match$11[0];
  let match$12 = UseLocalStorageJs("brush-overlay-mode", "overlay");
  let overlayMode = match$12[0];
  let showCursorOverlay;
  switch (overlayMode) {
    case "none" :
      showCursorOverlay = false;
      break;
    case "overlay" :
    case "color" :
      showCursorOverlay = true;
      break;
  }
  let match$13 = UseLocalStorageJs("grid-mode", "none");
  let gridMode = match$13[0];
  let match$14 = UseLocalStorageJs("canvas-silhouette", false);
  let isSilhouette = match$14[0];
  let match$15 = React.useState(() => false);
  let setCursorOverlayOff = match$15[1];
  let match$16 = React.useState(() => "16");
  let exportScaleInput = match$16[0];
  let match$17 = React.useState(() => true);
  let includeExportBackground = match$17[0];
  let match$18 = React.useState(() => "Scale");
  let resizeMode = match$18[0];
  let match$19 = React.useState(() => false);
  let setIsPickingColor = match$19[1];
  let isPickingColor = match$19[0];
  let match$20 = React.useState(() => {});
  let setHoveredPickColor = match$20[1];
  let clearHoverRef = React.useRef(() => {});
  let zoomRef = React.useRef(1);
  let panRef = React.useRef([
    0,
    0
  ]);
  let isMouseDown = useIsMouseDown();
  let onStartColorPick = () => setIsPickingColor(prev => {
    let next = !prev;
    setHoveredPickColor(param => {});
    if (next) {
      clearHoverRef.current();
      setCursorOverlayOff(param => false);
    }
    return next;
  });
  let canvasCount = canvases.length;
  let storeBoardValue = (id, boardValue) => {
    setCanvasBoards(prev => {
      let replaced = {
        contents: false
      };
      let next = prev.map(entry => {
        if (entry.id === id) {
          replaced.contents = true;
          return {
            id: entry.id,
            board: boardValue
          };
        } else {
          return entry;
        }
      });
      if (replaced.contents) {
        return next;
      } else {
        return next.concat([{
            id: id,
            board: boardValue
          }]);
      }
    });
    BoardStorageJs.saveBoard(id, boardValue);
  };
  let modifyBoardEntry = (id, updater) => {
    let updatedBoardRef = {
      contents: undefined
    };
    setCanvasBoards(prev => {
      let next = prev.map(entry => {
        if (entry.id !== id) {
          return entry;
        }
        let nextBoard = updater(entry.board);
        updatedBoardRef.contents = nextBoard;
        return {
          id: entry.id,
          board: nextBoard
        };
      });
      let match = updatedBoardRef.contents;
      if (match !== undefined) {
        return next;
      }
      let fallback = updater(Board.make(12, 12));
      updatedBoardRef.contents = fallback;
      return next.concat([{
          id: id,
          board: fallback
        }]);
    });
    let boardValue = updatedBoardRef.contents;
    if (boardValue === undefined) {
      return;
    }
    BoardStorageJs.saveBoard(id, boardValue);
  };
  React.useEffect(() => {
    Js_promise.then_(entries => {
      setCanvasBoards(param => entries);
      setBoardsLoaded(param => true);
      return Promise.resolve();
    }, BoardStorageJs.loadAllBoards());
  }, []);
  React.useEffect(() => {
    if (areBoardsLoaded && canvasCount === 0) {
      updateViewportCenter();
      let match = makeDefaultCanvas();
      let defaultCanvas = match[0];
      setCanvases(param => [defaultCanvas]);
      storeBoardValue(defaultCanvas.id, match[1]);
      setSelectedCanvasId(param => defaultCanvas.id);
    }
    
  }, [
    areBoardsLoaded,
    canvasCount
  ]);
  React.useEffect(() => {
    if (areBoardsLoaded) {
      canvases.forEach(canvas => {
        let hasBoard = Belt_Array.some(canvasBoards, entry => entry.id === canvas.id);
        if (hasBoard) {
          return;
        }
        let fallbackBoard = Board.make(12, 12);
        storeBoardValue(canvas.id, fallbackBoard);
      });
    }
    
  }, [
    areBoardsLoaded,
    canvases,
    canvasBoards
  ]);
  let selectedCanvas = selectedCanvasId !== undefined ? Belt_Array.getBy(canvases, canvas => canvas.id === selectedCanvasId) : undefined;
  let currentCanvas;
  if (selectedCanvas !== undefined) {
    currentCanvas = selectedCanvas;
  } else {
    let firstCanvas = canvases[0];
    currentCanvas = firstCanvas !== undefined ? firstCanvas : makeDefaultCanvas()[0];
  }
  let currentCanvasId = currentCanvas.id;
  let match$21 = React.useState(() => currentCanvas.isDotMask);
  let setIncludeExportDotMask = match$21[1];
  let includeExportDotMask = match$21[0];
  React.useEffect(() => {
    setIncludeExportDotMask(prev => {
      if (prev === currentCanvas.isDotMask) {
        return prev;
      } else {
        return currentCanvas.isDotMask;
      }
    });
  }, [currentCanvasId]);
  let currentCanvasIdRef = React.useRef(currentCanvasId);
  currentCanvasIdRef.current = currentCanvasId;
  React.useEffect(() => {
    if (canvases.length === 0) {
      if (selectedCanvasId !== undefined) {
        setSelectedCanvasId(param => {});
      }
      
    } else {
      let hasValidSelection = selectedCanvasId !== undefined ? Belt_Array.some(canvases, canvas => canvas.id === selectedCanvasId) : false;
      if (!hasValidSelection) {
        let firstCanvas = canvases[0];
        if (firstCanvas !== undefined) {
          setSelectedCanvasId(param => firstCanvas.id);
        }
        
      }
      
    }
  }, [
    canvases,
    selectedCanvasId
  ]);
  let entry = Belt_Array.getBy(canvasBoards, entry => entry.id === currentCanvasId);
  let board = entry !== undefined ? entry.board : Board.make(12, 12);
  let zoom = currentCanvas.zoom;
  let pan = currentCanvas.pan;
  let isDotMask = currentCanvas.isDotMask;
  let canvasBackgroundColor = currentCanvas.canvasBackgroundColor;
  let isCanvasBackgroundLight = _isLight(canvasBackgroundColor);
  let gridLineColor = isCanvasBackgroundLight ? "rgba(0, 0, 0, 0.25)" : "rgba(255, 255, 255, 0.25)";
  let checkeredPrimaryColor = isCanvasBackgroundLight ? "rgba(0, 0, 0, 0.15)" : "rgba(255, 255, 255, 0.15)";
  let checkeredSecondaryColor = isCanvasBackgroundLight ? "rgba(0, 0, 0, 0.00)" : "rgba(255, 255, 255, 0.00)";
  zoomRef.current = zoom;
  panRef.current = pan;
  let handlePickColor = (row, col) => {
    let pickedColor = Board.get(board, row, col);
    if (!(pickedColor == null)) {
      setMyColor(param => pickedColor);
      setBrushMode(param => "Color");
    }
    setIsPickingColor(param => false);
    setHoveredPickColor(param => {});
  };
  let updateCanvasById = (targetId, updater) => setCanvases(prev => prev.map(canvas => {
    if (canvas.id === targetId) {
      return updater(canvas);
    } else {
      return canvas;
    }
  }));
  let setCanvasDotMask = updater => updateCanvasById(currentCanvasIdRef.current, canvas => ({
    id: canvas.id,
    zoom: canvas.zoom,
    pan: canvas.pan,
    isDotMask: updater(canvas.isDotMask),
    canvasBackgroundColor: canvas.canvasBackgroundColor
  }));
  let setCanvasBackgroundColor = updater => updateCanvasById(currentCanvasIdRef.current, canvas => ({
    id: canvas.id,
    zoom: canvas.zoom,
    pan: canvas.pan,
    isDotMask: canvas.isDotMask,
    canvasBackgroundColor: updater(canvas.canvasBackgroundColor)
  }));
  let updatePan = updater => updateCanvasById(currentCanvasIdRef.current, canvas => {
    let nextPan = updater(canvas.pan);
    panRef.current = nextPan;
    return {
      id: canvas.id,
      zoom: canvas.zoom,
      pan: nextPan,
      isDotMask: canvas.isDotMask,
      canvasBackgroundColor: canvas.canvasBackgroundColor
    };
  });
  let adjustPan = (deltaX, deltaY) => updatePan(param => [
    param[0] + deltaX,
    param[1] + deltaY
  ]);
  let updateZoom = updater => updateCanvasById(currentCanvasIdRef.current, canvas => {
    let prevZoom = canvas.zoom;
    let nextZoom = clampZoom(updater(prevZoom));
    if (nextZoom !== prevZoom) {
      let match = viewportCenterRef.current;
      let centerY = match[1];
      let centerX = match[0];
      let match$1 = canvas.pan;
      let boardCenterX = (centerX - match$1[0]) / prevZoom;
      let boardCenterY = (centerY - match$1[1]) / prevZoom;
      let nextPanX = centerX - boardCenterX * nextZoom;
      let nextPanY = centerY - boardCenterY * nextZoom;
      let nextPan = [
        nextPanX,
        nextPanY
      ];
      zoomRef.current = nextZoom;
      panRef.current = nextPan;
      return {
        id: canvas.id,
        zoom: nextZoom,
        pan: nextPan,
        isDotMask: canvas.isDotMask,
        canvasBackgroundColor: canvas.canvasBackgroundColor
      };
    }
    zoomRef.current = nextZoom;
    return canvas;
  });
  let zoomIn = () => updateZoom(prev => prev * Initials.zoom_factor);
  let zoomOut = () => {
    let factor = 1 / Initials.zoom_factor;
    updateZoom(prev => prev * factor);
  };
  let fallbackBrush = React.useMemo(() => Array2D.make(3, 3, () => true), []);
  let fallbackTileMask = React.useMemo(() => Array2D.make(4, 4, () => true), []);
  let brush;
  if (selectedBrushId !== undefined) {
    let entry$1 = Belt_Array.getBy(savedBrushes, entry => entry.id === selectedBrushId);
    brush = entry$1 !== undefined ? entry$1.brush : fallbackBrush;
  } else {
    let entry$2 = savedBrushes[0];
    brush = entry$2 !== undefined ? entry$2.brush : fallbackBrush;
  }
  let tileMask;
  if (selectedTileMaskId !== undefined) {
    let entry$3 = Belt_Array.getBy(savedTileMasks, entry => entry.id === selectedTileMaskId);
    tileMask = entry$3 !== undefined ? entry$3.mask : fallbackTileMask;
  } else {
    let entry$4 = savedTileMasks[0];
    tileMask = entry$4 !== undefined ? entry$4.mask : fallbackTileMask;
  }
  let match$22 = Board.dims(board);
  let boardDimJ = match$22[1];
  let boardDimI = match$22[0];
  let fitZoom = computeZoomToFitForDimensions(boardDimI, boardDimJ);
  let zoomPercent = fitZoom !== undefined ? (
      fitZoom <= 0 ? zoom * 100 : zoom / fitZoom * 100
    ) : zoom * 100;
  let lastAutoCenteredDimsRef = React.useRef(undefined);
  let match$23 = Array2D.dims(brush);
  let brushDimJ = match$23[1];
  let brushDimI = match$23[0];
  let brushCenterDimI = brushDimI / 2 | 0;
  let brushCenterDimJ = brushDimJ / 2 | 0;
  let match$24 = Array2D.dims(tileMask);
  let tileMaskDimJ = match$24[1];
  let tileMaskDimI = match$24[0];
  let centerCanvasForDimensions = (dimI, dimJ) => {
    let match = computeCenteredPan(dimI, dimJ, zoomRef.current);
    let nextPanY = match[1];
    let nextPanX = match[0];
    updatePan(param => {
      let prevY = param[1];
      let prevX = param[0];
      if (prevX === nextPanX && prevY === nextPanY) {
        return [
          prevX,
          prevY
        ];
      } else {
        return [
          nextPanX,
          nextPanY
        ];
      }
    });
  };
  let centerCanvas = () => centerCanvasForDimensions(boardDimI, boardDimJ);
  let fitCanvasToViewportForDimensions = (dimI, dimJ) => {
    let nextZoom = computeZoomToFitForDimensions(dimI, dimJ);
    if (nextZoom !== undefined) {
      return updateCanvasById(currentCanvasIdRef.current, canvas => {
        let match = computeCenteredPan(dimI, dimJ, nextZoom);
        let nextPanY = match[1];
        let nextPanX = match[0];
        zoomRef.current = nextZoom;
        panRef.current = [
          nextPanX,
          nextPanY
        ];
        return {
          id: canvas.id,
          zoom: nextZoom,
          pan: [
            nextPanX,
            nextPanY
          ],
          isDotMask: canvas.isDotMask,
          canvasBackgroundColor: canvas.canvasBackgroundColor
        };
      });
    } else {
      return centerCanvasForDimensions(dimI, dimJ);
    }
  };
  let fitCanvasToViewport = () => fitCanvasToViewportForDimensions(boardDimI, boardDimJ);
  let match$25 = React.useState(() => boardDimI.toString());
  let setResizeRowsInput = match$25[1];
  let resizeRowsInput = match$25[0];
  let match$26 = React.useState(() => boardDimJ.toString());
  let setResizeColsInput = match$26[1];
  let resizeColsInput = match$26[0];
  React.useEffect(() => {
    setResizeRowsInput(param => boardDimI.toString());
    setResizeColsInput(param => boardDimJ.toString());
  }, [
    boardDimI,
    boardDimJ
  ]);
  React.useEffect(() => {
    let match = panRef.current;
    let hasCustomPan = match[0] !== 0 || match[1] !== 0;
    let match$1 = lastAutoCenteredDimsRef.current;
    if (match$1 !== undefined) {
      if (match$1[0] !== boardDimI || match$1[1] !== boardDimJ) {
        centerCanvasForDimensions(boardDimI, boardDimJ);
        lastAutoCenteredDimsRef.current = [
          boardDimI,
          boardDimJ
        ];
      }
      
    } else {
      if (!hasCustomPan) {
        centerCanvasForDimensions(boardDimI, boardDimJ);
      }
      lastAutoCenteredDimsRef.current = [
        boardDimI,
        boardDimJ
      ];
    }
  }, [
    boardDimI,
    boardDimJ,
    viewportCenter
  ]);
  let parsePositiveInt = value => {
    let parsed = Stdlib_Int.fromString(value, undefined);
    if (parsed !== undefined && parsed > 0) {
      return parsed;
    }
    
  };
  let parsePositiveFloat = value => {
    let parsed = Belt_Float.fromString(value);
    if (parsed !== undefined && parsed > 0) {
      return parsed;
    }
    
  };
  let mapIndex = (srcSize, dstSize, index) => {
    if (srcSize <= 1 || dstSize <= 1) {
      return 0;
    }
    let numerator = (index * (srcSize - 1 | 0) | 0) + ((dstSize - 1 | 0) / 2 | 0) | 0;
    let denominator = dstSize - 1 | 0;
    let mapped = Primitive_int.div(numerator, denominator);
    let maxIndex = srcSize - 1 | 0;
    if (mapped < 0) {
      return 0;
    } else if (mapped > maxIndex) {
      return maxIndex;
    } else {
      return mapped;
    }
  };
  let match$27 = parsePositiveInt(resizeRowsInput);
  let match$28 = parsePositiveInt(resizeColsInput);
  let canSubmitResize = match$27 !== undefined && match$28 !== undefined ? match$27 !== boardDimI || match$28 !== boardDimJ : false;
  let exportScaleValue = parsePositiveFloat(exportScaleInput);
  let canExport = Stdlib_Option.isSome(exportScaleValue);
  let handleResizeSubmit = () => {
    let match = parsePositiveInt(resizeRowsInput);
    let match$1 = parsePositiveInt(resizeColsInput);
    if (match === undefined) {
      return;
    }
    if (match$1 === undefined) {
      return;
    }
    if (resizeMode === "Scale") {
      modifyBoardEntry(currentCanvasIdRef.current, prev => {
        let match$2 = Board.dims(prev);
        let prevCols = match$2[1];
        let prevRows = match$2[0];
        let nextBoard = Board.make(match, match$1);
        if (prevRows === 0 || prevCols === 0) {
          return nextBoard;
        }
        for (let rowI = 0; rowI < match; ++rowI) {
          let srcRow = mapIndex(prevRows, match, rowI);
          for (let colJ = 0; colJ < match$1; ++colJ) {
            let srcCol = mapIndex(prevCols, match$1, colJ);
            Board.setInPlace(nextBoard, rowI, colJ, Board.get(prev, srcRow, srcCol));
          }
        }
        return nextBoard;
      });
    } else {
      modifyBoardEntry(currentCanvasIdRef.current, prev => {
        let nextBoard = Board.make(match, match$1);
        for (let rowI = 0; rowI < match; ++rowI) {
          for (let colJ = 0; colJ < match$1; ++colJ) {
            Board.setInPlace(nextBoard, rowI, colJ, Board.get(prev, rowI, colJ));
          }
        }
        return nextBoard;
      });
    }
    fitCanvasToViewportForDimensions(match, match$1);
    clearHoverRef.current();
    setCursorOverlayOff(param => true);
  };
  let handleExportPng = () => {
    if (exportScaleValue !== undefined) {
      let prim2 = {
        includeBackground: includeExportBackground,
        backgroundColor: canvasBackgroundColor,
        includeDotMask: includeExportDotMask,
        dotMaskColor: canvasBackgroundColor
      };
      ExportBoardJs.exportBoardAsPng(board, exportScaleValue, prim2);
      return;
    }
    
  };
  let canDeleteSelectedBrush = savedBrushes.length > 1;
  let canDeleteSelectedTileMask = savedTileMasks.length > 1;
  let handleAddBrush = () => {
    let newBrush = Board.toBoolGrid(board);
    let newEntry_id = "brush-" + generateCanvasId();
    let newEntry = {
      id: newEntry_id,
      brush: newBrush
    };
    setSavedBrushes(v => v.concat([newEntry]));
    setSelectedBrushId(param => newEntry_id);
  };
  let handleDeleteSelectedBrush = () => {
    if (canDeleteSelectedBrush) {
      return setSavedBrushes(prev => {
        let currentIndex = Belt_Option.getWithDefault(Stdlib_Option.flatMap(selectedBrushId, id => Belt_Array.getIndexBy(prev, entry => entry.id === id)), 0);
        let next = Stdlib_Option.mapOr(selectedBrushId, prev, id => Belt_Array.keep(prev, entry => entry.id !== id));
        let entry = next[currentIndex];
        let nextSelectionId;
        if (entry !== undefined) {
          nextSelectionId = entry.id;
        } else if (currentIndex > 0) {
          let entry$1 = next[currentIndex - 1 | 0];
          nextSelectionId = entry$1 !== undefined ? entry$1.id : Stdlib_Option.map(next[0], entry => entry.id);
        } else {
          nextSelectionId = Stdlib_Option.map(next[0], entry => entry.id);
        }
        setSelectedBrushId(param => nextSelectionId);
        return next;
      });
    }
    
  };
  let handleAddTileMask = () => {
    let newTileMask = Board.toBoolGrid(board);
    let newEntry_id = "tile-mask-" + generateCanvasId();
    let newEntry = {
      id: newEntry_id,
      mask: newTileMask
    };
    setSavedTileMasks(prev => prev.concat([newEntry]));
    setSelectedTileMaskId(param => newEntry_id);
  };
  let handleDeleteSelectedTileMask = () => {
    if (canDeleteSelectedTileMask) {
      return setSavedTileMasks(prev => {
        let currentIndex = Belt_Option.getWithDefault(Stdlib_Option.flatMap(selectedTileMaskId, id => Belt_Array.getIndexBy(prev, entry => entry.id === id)), 0);
        let next = Stdlib_Option.mapOr(selectedTileMaskId, prev, id => Belt_Array.keep(prev, entry => entry.id !== id));
        let entry = next[currentIndex];
        let nextSelectionId;
        if (entry !== undefined) {
          nextSelectionId = entry.id;
        } else if (currentIndex > 0) {
          let entry$1 = next[currentIndex - 1 | 0];
          nextSelectionId = entry$1 !== undefined ? entry$1.id : Stdlib_Option.map(next[0], entry => entry.id);
        } else {
          nextSelectionId = Stdlib_Option.map(next[0], entry => entry.id);
        }
        setSelectedTileMaskId(param => nextSelectionId);
        return next;
      });
    }
    
  };
  let canDeleteCanvas = canvasCount > 1;
  let handleAddCanvas = () => {
    let newBoard = Board.make(boardDimI, boardDimJ);
    let match = computeFitViewForDimensions(boardDimI, boardDimJ);
    let newPan = match[1];
    let fittedZoom = match[0];
    let newCanvas = makeCanvas(fittedZoom, newPan, false, canvasBackgroundColor);
    setCanvases(prev => prev.concat([newCanvas]));
    storeBoardValue(newCanvas.id, newBoard);
    setSelectedCanvasId(param => newCanvas.id);
    zoomRef.current = fittedZoom;
    panRef.current = newPan;
    clearHoverRef.current();
    setCursorOverlayOff(param => true);
    lastAutoCenteredDimsRef.current = [
      boardDimI,
      boardDimJ
    ];
  };
  let handleDeleteCanvas = () => {
    if (!canDeleteCanvas) {
      return;
    }
    let currentIndex = Belt_Array.getIndexBy(canvases, canvas => canvas.id === currentCanvasId);
    let nextSelectionId;
    if (currentIndex !== undefined) {
      let nextCanvas = canvases[currentIndex + 1 | 0];
      if (nextCanvas !== undefined) {
        nextSelectionId = nextCanvas.id;
      } else if (currentIndex > 0) {
        let prevCanvas = canvases[currentIndex - 1 | 0];
        nextSelectionId = prevCanvas !== undefined ? prevCanvas.id : undefined;
      } else {
        nextSelectionId = undefined;
      }
    } else {
      nextSelectionId = Stdlib_Option.flatMap(canvases[0], canvas => {
        if (canvas.id === currentCanvasId) {
          return;
        } else {
          return canvas.id;
        }
      });
    }
    setCanvases(prev => Belt_Array.keep(prev, canvas => canvas.id !== currentCanvasId));
    setCanvasBoards(prev => Belt_Array.keep(prev, entry => entry.id !== currentCanvasId));
    BoardStorageJs.deleteBoard(currentCanvasId);
    setSelectedCanvasId(param => nextSelectionId);
    clearHoverRef.current();
    setCursorOverlayOff(param => true);
  };
  let handleSelectCanvas = canvasId => {
    let isAlreadySelected = selectedCanvasId !== undefined ? selectedCanvasId === canvasId : false;
    if (!isAlreadySelected) {
      setSelectedCanvasId(param => canvasId);
    }
    clearHoverRef.current();
    setCursorOverlayOff(param => true);
  };
  let onMouseMove = param => setCursorOverlayOff(param => false);
  let getBrushColor = () => {
    if (brushMode === "Color") {
      return myColor;
    } else {
      return null;
    }
  };
  let applyBrush = (clickI, clickJ) => {
    UseLocalStorageJs$1.setLocalStoragePersistencePaused(true);
    let brushColor = getBrushColor();
    modifyBoardEntry(currentCanvasIdRef.current, prev => {
      let match = Board.dims(prev);
      let cols = match[1];
      let rows = match[0];
      if (rows === 0 || cols === 0) {
        return prev;
      }
      let updates = [];
      for (let brushI = 0; brushI < brushDimI; ++brushI) {
        let boardI = (clickI - brushCenterDimI | 0) + brushI | 0;
        if (boardI >= 0 && boardI < rows) {
          for (let brushJ = 0; brushJ < brushDimJ; ++brushJ) {
            let boardJ = (clickJ - brushCenterDimJ | 0) + brushJ | 0;
            if (boardJ >= 0 && boardJ < cols) {
              let brushAllows = Stdlib_Option.getOr(Array2D.check(brush, brushI, brushJ), false);
              if (brushAllows) {
                let maskAllows = tileMaskDimI > 0 && tileMaskDimJ > 0 ? Stdlib_Option.getOr(Array2D.check(tileMask, Primitive_int.mod_(boardI, tileMaskDimI), Primitive_int.mod_(boardJ, tileMaskDimJ)), false) : true;
                if (maskAllows) {
                  updates.push([
                    boardI,
                    boardJ,
                    brushColor
                  ]);
                }
                
              }
              
            }
            
          }
        }
        
      }
      if (updates.length === 0) {
        return prev;
      } else {
        return Board.setMany(prev, updates);
      }
    });
  };
  React.useEffect(() => {
    window.addEventListener("mousemove", onMouseMove);
    return () => {
      window.removeEventListener("mousemove", onMouseMove);
    };
  }, []);
  React.useEffect(() => {
    let handleKeyDown = event => {
      if (event.metaKey) {
        let match = event.key;
        switch (match) {
          case "[" :
            event.preventDefault();
            let factor = 1 / Initials.zoom_factor;
            return updateZoom(prev => prev * factor);
          case "]" :
            event.preventDefault();
            return updateZoom(prev => prev * Initials.zoom_factor);
          default:
            return;
        }
      } else {
        let match$1 = event.key;
        switch (match$1) {
          case "ArrowDown" :
            event.preventDefault();
            return adjustPan(0, 20);
          case "ArrowLeft" :
            event.preventDefault();
            return adjustPan(- 20, 0);
          case "ArrowRight" :
            event.preventDefault();
            return adjustPan(20, 0);
          case "ArrowUp" :
            event.preventDefault();
            return adjustPan(0, - 20);
          default:
            return;
        }
      }
    };
    window.addEventListener("keydown", handleKeyDown);
    return () => {
      window.removeEventListener("keydown", handleKeyDown);
    };
  }, []);
  let offsetXString = pan[0].toString();
  let offsetYString = pan[1].toString();
  let zoomString = zoom.toString();
  let transformValue = "translate3d(" + offsetXString + "px, " + offsetYString + "px, 0) scale(" + zoomString + ")";
  let onSelectUsedColor = color => {
    setMyColor(param => color);
    setBrushMode(param => "Color");
  };
  let onReplaceUsedColor = color => modifyBoardEntry(currentCanvasIdRef.current, prev => {
    let match = Board.dims(prev);
    let cols = match[1];
    let replacement = myColor;
    let updates = [];
    for (let row = 0, row_finish = match[0]; row < row_finish; ++row) {
      for (let col = 0; col < cols; ++col) {
        let existing = Board.get(prev, row, col);
        if (!(existing == null) && existing === color) {
          updates.push([
            row,
            col,
            replacement
          ]);
        }
        
      }
    }
    if (updates.length === 0) {
      return prev;
    } else {
      return Board.setMany(prev, updates);
    }
  });
  if (areBoardsLoaded) {
    return JsxRuntime.jsxs("div", {
      children: [
        JsxRuntime.jsxs("div", {
          children: [
            JsxRuntime.jsx(ZoomControl.make, {
              zoomOut: zoomOut,
              zoomIn: zoomIn,
              centerCanvas: centerCanvas,
              fitCanvasToViewport: fitCanvasToViewport,
              zoomPercent: zoomPercent
            }),
            JsxRuntime.jsxs("div", {
              children: [
                JsxRuntime.jsx(SavedBrushesPanel.make, {
                  savedBrushes: savedBrushes,
                  selectedBrushId: selectedBrushId,
                  setSelectedBrushId: setSelectedBrushId,
                  handleAddBrush: handleAddBrush,
                  canDeleteSelectedBrush: canDeleteSelectedBrush,
                  handleDeleteSelectedBrush: handleDeleteSelectedBrush,
                  canSaveBrush: boardDimI <= 32 && boardDimJ <= 32
                }),
                JsxRuntime.jsx(SavedTileMasksPanel.make, {
                  savedTileMasks: savedTileMasks,
                  selectedTileMaskId: selectedTileMaskId,
                  setSelectedTileMaskId: setSelectedTileMaskId,
                  handleAddTileMask: handleAddTileMask,
                  canDeleteSelectedTileMask: canDeleteSelectedTileMask,
                  handleDeleteSelectedTileMask: handleDeleteSelectedTileMask,
                  canSaveTileMask: boardDimI <= 32 && boardDimJ <= 32
                })
              ],
              className: "flex flex-row gap-2 h-full flex-none p-2"
            })
          ],
          className: "flex flex-col flex-none overflow-x-hidden divide-y divide-gray-300"
        }),
        JsxRuntime.jsxs("div", {
          children: [
            JsxRuntime.jsx("div", {
              children: JsxRuntime.jsx(CanvasViewport.make, {
                canvasContainerRef: canvasContainerRef,
                board: board,
                boardDimI: boardDimI,
                boardDimJ: boardDimJ,
                transformValue: transformValue,
                zoom: zoom,
                pan: pan,
                cursorOverlayOff: match$15[0],
                setCursorOverlayOff: setCursorOverlayOff,
                isMouseDown: isMouseDown,
                applyBrush: applyBrush,
                handlePickColor: handlePickColor,
                setHoveredPickColor: setHoveredPickColor,
                isPickingColor: isPickingColor,
                showCursorOverlay: showCursorOverlay,
                overlayMode: overlayMode,
                overlayColor: myColor,
                gridMode: gridMode,
                canvasBackgroundColor: canvasBackgroundColor,
                gridLineColor: gridLineColor,
                checkeredPrimaryColor: checkeredPrimaryColor,
                checkeredSecondaryColor: checkeredSecondaryColor,
                viewportBackgroundColor: viewportBackgroundColor,
                isSilhouette: isSilhouette,
                clearHoverRef: clearHoverRef,
                brush: brush,
                brushDimI: brushDimI,
                brushDimJ: brushDimJ,
                brushCenterDimI: brushCenterDimI,
                brushCenterDimJ: brushCenterDimJ,
                tileMask: tileMask,
                tileMaskDimI: tileMaskDimI,
                tileMaskDimJ: tileMaskDimJ,
                isDotMask: isDotMask
              }),
              className: "flex-1 pt-2"
            }),
            JsxRuntime.jsx(CanvasThumbnails.make, {
              canvases: canvases,
              canvasBoards: canvasBoards,
              currentCanvasId: currentCanvasId,
              canDeleteCanvas: canDeleteCanvas,
              handleDeleteCanvas: handleDeleteCanvas,
              handleAddCanvas: handleAddCanvas,
              handleSelectCanvas: handleSelectCanvas,
              isMouseDown: isMouseDown
            })
          ],
          className: "flex flex-col flex-1 overflow-x-hidden"
        }),
        JsxRuntime.jsxs("div", {
          children: [
            JsxRuntime.jsx(ColorControl.make, {
              brushMode: brushMode,
              setBrushMode: setBrushMode,
              myColor: myColor,
              setMyColor: setMyColor,
              hoveredPickColor: match$20[0],
              isPickingColor: isPickingColor,
              onStartColorPick: onStartColorPick,
              canvasBackgroundColor: canvasBackgroundColor
            }),
            JsxRuntime.jsxs("div", {
              children: [
                JsxRuntime.jsx(ColorsUsed.make, {
                  board: board,
                  onSelectUsedColor: onSelectUsedColor,
                  onReplaceUsedColor: onReplaceUsedColor,
                  myColor: myColor,
                  isMouseDown: isMouseDown
                }),
                JsxRuntime.jsx(BrushOverlayControl.make, {
                  overlayMode: overlayMode,
                  setOverlayMode: match$12[1]
                }),
                JsxRuntime.jsx(CanvasGridControl.make, {
                  gridMode: gridMode,
                  setGridMode: match$13[1]
                }),
                JsxRuntime.jsx(CanvasColorsControl.make, {
                  myColor: myColor,
                  canvasBackgroundColor: canvasBackgroundColor,
                  setCanvasBackgroundColor: setCanvasBackgroundColor,
                  viewportBackgroundColor: viewportBackgroundColor,
                  setViewportBackgroundColor: match$5[1]
                }),
                JsxRuntime.jsx(SilhouetteControl.make, {
                  isSilhouette: isSilhouette,
                  setIsSilhouette: match$14[1]
                }),
                JsxRuntime.jsx(DotModeControl.make, {
                  isDotMask: isDotMask,
                  setCanvasDotMask: setCanvasDotMask
                }),
                JsxRuntime.jsx(CanvasSizeControl.make, {
                  resizeRowsInput: resizeRowsInput,
                  setResizeRowsInput: setResizeRowsInput,
                  resizeColsInput: resizeColsInput,
                  setResizeColsInput: setResizeColsInput,
                  resizeMode: resizeMode,
                  setResizeMode: match$18[1],
                  canSubmitResize: canSubmitResize,
                  handleResizeSubmit: handleResizeSubmit
                }),
                JsxRuntime.jsx(ExportControl.make, {
                  exportScaleInput: exportScaleInput,
                  setExportScaleInput: match$16[1],
                  includeExportBackground: includeExportBackground,
                  setIncludeExportBackground: match$17[1],
                  includeExportDotMask: includeExportDotMask,
                  setIncludeExportDotMask: setIncludeExportDotMask,
                  canExport: canExport,
                  onExport: handleExportPng
                })
              ],
              className: "overflow-y-scroll flex-1 flex flex-col py-2 divide-y divide-gray-300"
            })
          ],
          className: " h-full overflow-x-visible flex flex-col w-48 py-2"
        })
      ],
      className: " flex flex-row h-dvh overflow-x-hidden"
    });
  } else {
    return JsxRuntime.jsx("div", {
      children: "Loading canvasesâ€¦",
      className: "flex h-dvh items-center justify-center text-sm text-gray-500"
    });
  }
}

let make = App;

export {
  make,
}
/* defaultTileMaskEntries Not a pure module */
