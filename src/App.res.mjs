// Generated by ReScript, PLEASE EDIT WITH CARE

import * as React from "react";
import * as Array2D from "./Array2D.res.mjs";
import * as Initials from "./Initials.res.mjs";
import * as Belt_Array from "rescript/lib/es6/Belt_Array.js";
import * as Belt_Float from "rescript/lib/es6/Belt_Float.js";
import * as Stdlib_Int from "rescript/lib/es6/Stdlib_Int.js";
import * as ControlsPanel from "./ControlsPanel.res.mjs";
import * as Primitive_int from "rescript/lib/es6/Primitive_int.js";
import * as Stdlib_Option from "rescript/lib/es6/Stdlib_Option.js";
import * as CanvasViewport from "./CanvasViewport.res.mjs";
import * as ExportBoardJs from "./exportBoard.js";
import * as CanvasThumbnails from "./CanvasThumbnails.res.mjs";
import * as SavedBrushesPanel from "./SavedBrushesPanel.res.mjs";
import * as JsxRuntime from "react/jsx-runtime";
import * as SavedTileMasksPanel from "./SavedTileMasksPanel.res.mjs";
import UseLocalStorageJs from "./useLocalStorage.js";

function generateCanvasId() {
  let timestamp = Date.now().toString();
  let random = Math.random().toString();
  return timestamp + "-" + random;
}

function makeCanvas(board, zoom, pan) {
  return {
    id: generateCanvasId(),
    board: board,
    zoom: zoom,
    pan: pan
  };
}

function useIsMouseDown() {
  let match = React.useState(() => false);
  let setIsMouseDown = match[1];
  React.useEffect(() => {
    let downHandler = param => setIsMouseDown(param => true);
    let upHandler = param => setIsMouseDown(param => false);
    window.addEventListener("mousedown", downHandler);
    window.addEventListener("mouseup", upHandler);
    return () => {
      window.removeEventListener("mousedown", downHandler);
      window.removeEventListener("mouseup", upHandler);
    };
  }, []);
  return match[0];
}

let defaultTileMasks = [
  [
    [
      true,
      true
    ],
    [
      true,
      true
    ]
  ],
  [
    [
      true,
      false
    ],
    [
      false,
      true
    ]
  ],
  [
    [
      false,
      true
    ],
    [
      true,
      false
    ]
  ],
  [
    [
      false,
      true
    ],
    [
      false,
      true
    ]
  ],
  [
    [
      true,
      false
    ],
    [
      true,
      false
    ]
  ],
  [
    [
      false,
      false
    ],
    [
      true,
      true
    ]
  ],
  [
    [
      true,
      true
    ],
    [
      false,
      false
    ]
  ],
  [
    [
      true,
      false,
      false
    ],
    [
      false,
      true,
      false
    ],
    [
      false,
      false,
      true
    ]
  ]
];

let defaultBrushes = [
  Array2D.make(1, 1, () => true),
  Array2D.make(2, 2, () => true),
  Array2D.make(3, 3, () => true),
  Array2D.make(4, 4, () => true),
  Array2D.make(8, 8, () => true),
  Array2D.make(12, 12, () => true),
  Array2D.make(16, 16, () => true)
];

function App(props) {
  let match = UseLocalStorageJs("brush-mode", "Color");
  let brushMode = match[0];
  let makeDefaultCanvas = () => makeCanvas(Array2D.make(12, 12, () => null), 1, [
    0,
    0
  ]);
  let match$1 = UseLocalStorageJs("canvases", [makeDefaultCanvas()]);
  let setCanvases = match$1[1];
  let canvases = match$1[0];
  let match$2 = UseLocalStorageJs("selected-canvas-id", "");
  let setSelectedCanvasId = match$2[1];
  let selectedCanvasId = match$2[0];
  let match$3 = UseLocalStorageJs("brush", Array2D.make(3, 3, () => true));
  let brush = match$3[0];
  let match$4 = UseLocalStorageJs("saved-brushes", defaultBrushes);
  let setSavedBrushes = match$4[1];
  let savedBrushes = match$4[0];
  let match$5 = UseLocalStorageJs("saved-tile-masks", defaultTileMasks);
  let setSavedTileMasks = match$5[1];
  let savedTileMasks = match$5[0];
  let match$6 = UseLocalStorageJs("selected-tile-mask-index", 0);
  let setSelectedTileMaskIndex = match$6[1];
  let selectedTileMaskIndex = match$6[0];
  let match$7 = UseLocalStorageJs("tile-mask", Array2D.make(4, 4, () => true));
  let setTileMask = match$7[1];
  let tileMask = match$7[0];
  let match$8 = UseLocalStorageJs("show-cursor-overlay", true);
  let showCursorOverlay = match$8[0];
  let match$9 = UseLocalStorageJs("my-color", Initials.myColor);
  let myColor = match$9[0];
  let match$10 = UseLocalStorageJs("canvas-background-color", Initials.canvasBackgroundColor);
  let canvasBackgroundColor = match$10[0];
  let match$11 = UseLocalStorageJs("viewport-background-color", Initials.viewportBackgroundColor);
  let viewportBackgroundColor = match$11[0];
  let match$12 = UseLocalStorageJs("canvas-silhouette", false);
  let isSilhouette = match$12[0];
  let match$13 = React.useState(() => false);
  let setCursorOverlayOff = match$13[1];
  let match$14 = React.useState(() => "1");
  let exportScaleInput = match$14[0];
  let match$15 = React.useState(() => true);
  let includeExportBackground = match$15[0];
  let match$16 = React.useState(() => "Scale");
  let resizeMode = match$16[0];
  let clearHoverRef = React.useRef(() => {});
  let zoomRef = React.useRef(1);
  let panRef = React.useRef([
    0,
    0
  ]);
  let canvasContainerRef = React.useRef(null);
  let match$17 = React.useState(() => [
    192,
    192
  ]);
  let setViewportCenter = match$17[1];
  let viewportCenter = match$17[0];
  let viewportCenterRef = React.useRef(viewportCenter);
  viewportCenterRef.current = viewportCenter;
  let updateViewportCenter = () => {
    let element = canvasContainerRef.current;
    if (element == null) {
      return;
    }
    let rect = element.getBoundingClientRect();
    setViewportCenter(param => [
      rect.width / 2,
      rect.height / 2
    ]);
  };
  React.useEffect(() => {
    updateViewportCenter();
    let handleResize = param => updateViewportCenter();
    window.addEventListener("resize", handleResize);
    return () => {
      window.removeEventListener("resize", handleResize);
    };
  }, []);
  let clampZoom = value => {
    let cappedMax = value > Initials.maxZoomIn ? Initials.maxZoomIn : value;
    if (cappedMax < Initials.maxZoomOut) {
      return Initials.maxZoomOut;
    } else {
      return cappedMax;
    }
  };
  let isMouseDown = useIsMouseDown();
  let canvasCount = canvases.length;
  React.useEffect(() => {
    if (canvasCount === 0) {
      let defaultCanvas = makeDefaultCanvas();
      setCanvases(param => [defaultCanvas]);
      setSelectedCanvasId(param => defaultCanvas.id);
    }
    
  }, []);
  let canvas = Belt_Array.getBy(canvases, canvas => canvas.id === selectedCanvasId);
  let currentCanvas;
  if (canvas !== undefined) {
    currentCanvas = canvas;
  } else {
    let firstCanvas = canvases[0];
    currentCanvas = firstCanvas !== undefined ? firstCanvas : makeDefaultCanvas();
  }
  let currentCanvasId = currentCanvas.id;
  let currentCanvasIdRef = React.useRef(currentCanvasId);
  currentCanvasIdRef.current = currentCanvasId;
  React.useEffect(() => {
    let hasValidSelection = Belt_Array.some(canvases, canvas => canvas.id === selectedCanvasId);
    if (!hasValidSelection) {
      let firstCanvas = canvases[0];
      if (firstCanvas !== undefined && firstCanvas.id !== selectedCanvasId) {
        setSelectedCanvasId(param => firstCanvas.id);
      }
      
    }
    
  }, [
    canvases,
    selectedCanvasId
  ]);
  React.useEffect(() => {
    let requiresMigration = Belt_Array.some(canvases, canvas => {
      if (typeof canvas.id !== "string") {
        return true;
      } else {
        return canvas.id === "";
      }
    });
    if (requiresMigration) {
      setCanvases(prev => prev.map((canvas, idx) => {
        if (typeof canvas.id === "string" && canvas.id !== "") {
          return canvas;
        }
        let uniqueSuffix = "-" + idx.toString();
        return {
          id: generateCanvasId() + uniqueSuffix,
          board: canvas.board,
          zoom: canvas.zoom,
          pan: canvas.pan
        };
      }));
    }
    
  }, canvases);
  let board = currentCanvas.board;
  let zoom = currentCanvas.zoom;
  let pan = currentCanvas.pan;
  zoomRef.current = zoom;
  panRef.current = pan;
  let updateCanvasById = (targetId, updater) => setCanvases(prev => {
    if (prev.length === 0) {
      return [updater(makeDefaultCanvas())];
    } else {
      return prev.map(canvas => {
        if (canvas.id === targetId) {
          return updater(canvas);
        } else {
          return canvas;
        }
      });
    }
  });
  let setBoard = updater => updateCanvasById(currentCanvasIdRef.current, canvas => ({
    id: canvas.id,
    board: updater(canvas.board),
    zoom: canvas.zoom,
    pan: canvas.pan
  }));
  let updatePan = updater => updateCanvasById(currentCanvasIdRef.current, canvas => {
    let nextPan = updater(canvas.pan);
    panRef.current = nextPan;
    return {
      id: canvas.id,
      board: canvas.board,
      zoom: canvas.zoom,
      pan: nextPan
    };
  });
  let adjustPan = (deltaX, deltaY) => updatePan(param => [
    param[0] + deltaX,
    param[1] + deltaY
  ]);
  let updateZoom = updater => updateCanvasById(currentCanvasIdRef.current, canvas => {
    let prevZoom = canvas.zoom;
    let nextZoom = clampZoom(updater(prevZoom));
    if (nextZoom !== prevZoom) {
      let match = viewportCenterRef.current;
      let centerY = match[1];
      let centerX = match[0];
      let match$1 = canvas.pan;
      let boardCenterX = (centerX - match$1[0]) / prevZoom;
      let boardCenterY = (centerY - match$1[1]) / prevZoom;
      let nextPanX = centerX - boardCenterX * nextZoom;
      let nextPanY = centerY - boardCenterY * nextZoom;
      let nextPan = [
        nextPanX,
        nextPanY
      ];
      zoomRef.current = nextZoom;
      panRef.current = nextPan;
      return {
        id: canvas.id,
        board: canvas.board,
        zoom: nextZoom,
        pan: nextPan
      };
    }
    zoomRef.current = nextZoom;
    return canvas;
  });
  let resetZoom = () => updateZoom(param => 1);
  let zoomIn = () => updateZoom(prev => prev * Initials.zoom_factor);
  let zoomOut = () => {
    let factor = 1 / Initials.zoom_factor;
    updateZoom(prev => prev * factor);
  };
  let match$18 = Array2D.dims(board);
  let boardDimJ = match$18[1];
  let boardDimI = match$18[0];
  let lastAutoCenteredDimsRef = React.useRef(undefined);
  let match$19 = Array2D.dims(brush);
  let brushDimJ = match$19[1];
  let brushDimI = match$19[0];
  let brushCenterDimI = brushDimI / 2 | 0;
  let brushCenterDimJ = brushDimJ / 2 | 0;
  let match$20 = Array2D.dims(tileMask);
  let tileMaskDimJ = match$20[1];
  let tileMaskDimI = match$20[0];
  let computeCenteredPan = (dimI, dimJ, zoomValue) => {
    let boardWidth = dimI * 16;
    let boardHeight = dimJ * 16;
    let nextPanX = viewportCenter[0] - boardWidth * zoomValue / 2;
    let nextPanY = viewportCenter[1] - boardHeight * zoomValue / 2;
    return [
      nextPanX,
      nextPanY
    ];
  };
  let centerCanvas = () => {
    let match = computeCenteredPan(boardDimI, boardDimJ, zoomRef.current);
    let nextPanY = match[1];
    let nextPanX = match[0];
    updatePan(param => {
      let prevY = param[1];
      let prevX = param[0];
      if (prevX === nextPanX && prevY === nextPanY) {
        return [
          prevX,
          prevY
        ];
      } else {
        return [
          nextPanX,
          nextPanY
        ];
      }
    });
  };
  let fitCanvasToViewport = () => {
    let containerElement = canvasContainerRef.current;
    if (containerElement == null) {
      return centerCanvas();
    }
    let rect = containerElement.getBoundingClientRect();
    let viewportWidth = rect.width;
    let viewportHeight = rect.height;
    let boardWidth = boardDimJ * 16;
    let boardHeight = boardDimI * 16;
    if (viewportWidth <= 0 || viewportHeight <= 0 || boardWidth <= 0 || boardHeight <= 0) {
      return centerCanvas();
    }
    let zoomByWidth = viewportWidth / boardWidth;
    let zoomByHeight = viewportHeight / boardHeight;
    let zoomToFit = zoomByWidth < zoomByHeight ? zoomByWidth : zoomByHeight;
    let nextZoom = clampZoom(zoomToFit);
    updateCanvasById(currentCanvasIdRef.current, canvas => {
      let match = computeCenteredPan(boardDimI, boardDimJ, nextZoom);
      let nextPanY = match[1];
      let nextPanX = match[0];
      zoomRef.current = nextZoom;
      panRef.current = [
        nextPanX,
        nextPanY
      ];
      return {
        id: canvas.id,
        board: canvas.board,
        zoom: nextZoom,
        pan: [
          nextPanX,
          nextPanY
        ]
      };
    });
  };
  let centerCanvasForDimensions = (dimI, dimJ) => {
    let match = computeCenteredPan(dimI, dimJ, zoomRef.current);
    let nextPanY = match[1];
    let nextPanX = match[0];
    updatePan(param => {
      let prevY = param[1];
      let prevX = param[0];
      if (prevX === nextPanX && prevY === nextPanY) {
        return [
          prevX,
          prevY
        ];
      } else {
        return [
          nextPanX,
          nextPanY
        ];
      }
    });
  };
  let match$21 = React.useState(() => boardDimI.toString());
  let setResizeRowsInput = match$21[1];
  let resizeRowsInput = match$21[0];
  let match$22 = React.useState(() => boardDimJ.toString());
  let setResizeColsInput = match$22[1];
  let resizeColsInput = match$22[0];
  React.useEffect(() => {
    setResizeRowsInput(param => boardDimI.toString());
    setResizeColsInput(param => boardDimJ.toString());
  }, [
    boardDimI,
    boardDimJ
  ]);
  React.useEffect(() => {
    let match = panRef.current;
    let hasCustomPan = match[0] !== 0 || match[1] !== 0;
    let match$1 = lastAutoCenteredDimsRef.current;
    if (match$1 !== undefined) {
      if (match$1[0] !== boardDimI || match$1[1] !== boardDimJ) {
        centerCanvasForDimensions(boardDimI, boardDimJ);
        lastAutoCenteredDimsRef.current = [
          boardDimI,
          boardDimJ
        ];
      }
      
    } else {
      if (!hasCustomPan) {
        centerCanvasForDimensions(boardDimI, boardDimJ);
      }
      lastAutoCenteredDimsRef.current = [
        boardDimI,
        boardDimJ
      ];
    }
  }, [
    boardDimI,
    boardDimJ,
    viewportCenter
  ]);
  React.useEffect(() => {
    let mask = savedTileMasks[selectedTileMaskIndex];
    if (mask !== undefined) {
      if (!Array2D.isEqual(mask, tileMask)) {
        setTileMask(param => mask);
      }
      return;
    }
    if (savedTileMasks.length > 0) {
      let fallbackIndex = selectedTileMaskIndex >= savedTileMasks.length ? savedTileMasks.length - 1 | 0 : 0;
      setSelectedTileMaskIndex(param => fallbackIndex);
    }
    
  }, [
    savedTileMasks,
    selectedTileMaskIndex
  ]);
  let parsePositiveInt = value => {
    let parsed = Stdlib_Int.fromString(value, undefined);
    if (parsed !== undefined && parsed > 0) {
      return parsed;
    }
    
  };
  let parsePositiveFloat = value => {
    let parsed = Belt_Float.fromString(value);
    if (parsed !== undefined && parsed > 0) {
      return parsed;
    }
    
  };
  let mapIndex = (srcSize, dstSize, index) => {
    if (srcSize <= 1 || dstSize <= 1) {
      return 0;
    }
    let numerator = (index * (srcSize - 1 | 0) | 0) + ((dstSize - 1 | 0) / 2 | 0) | 0;
    let denominator = dstSize - 1 | 0;
    let mapped = Primitive_int.div(numerator, denominator);
    let maxIndex = srcSize - 1 | 0;
    if (mapped < 0) {
      return 0;
    } else if (mapped > maxIndex) {
      return maxIndex;
    } else {
      return mapped;
    }
  };
  let match$23 = parsePositiveInt(resizeRowsInput);
  let match$24 = parsePositiveInt(resizeColsInput);
  let canSubmitResize = match$23 !== undefined && match$24 !== undefined ? match$23 !== boardDimI || match$24 !== boardDimJ : false;
  let exportScaleValue = parsePositiveFloat(exportScaleInput);
  let canExport = Stdlib_Option.isSome(exportScaleValue);
  let handleResizeSubmit = () => {
    let match = parsePositiveInt(resizeRowsInput);
    let match$1 = parsePositiveInt(resizeColsInput);
    if (match === undefined) {
      return;
    }
    if (match$1 === undefined) {
      return;
    }
    if (resizeMode === "Scale") {
      setBoard(prev => {
        let match$2 = Array2D.dims(prev);
        let prevCols = match$2[1];
        let prevRows = match$2[0];
        if (prevRows === 0 || prevCols === 0) {
          return Array2D.make(match, match$1, () => null);
        } else {
          return Array2D.make(match, match$1, () => null).map((row, rowI) => row.map((param, colJ) => {
            let srcRow = mapIndex(prevRows, match, rowI);
            let srcCol = mapIndex(prevCols, match$1, colJ);
            return Stdlib_Option.getOr(Array2D.check(prev, srcRow, srcCol), null);
          }));
        }
      });
    } else {
      setBoard(prev => Array2D.make(match, match$1, () => null).map((row, rowI) => row.map((param, colJ) => Stdlib_Option.getOr(Array2D.check(prev, rowI, colJ), null))));
    }
    clearHoverRef.current();
    setCursorOverlayOff(param => true);
  };
  let handleExportPng = () => {
    if (exportScaleValue !== undefined) {
      let prim2 = {
        includeBackground: includeExportBackground,
        backgroundColor: canvasBackgroundColor
      };
      ExportBoardJs.exportBoardAsPng(board, exportScaleValue, prim2);
      return;
    }
    
  };
  let selectedSavedBrushIndex = Belt_Array.getIndexBy(savedBrushes, savedBrush => Array2D.isEqual(savedBrush, brush));
  let canDeleteSelectedBrush = Stdlib_Option.isSome(selectedSavedBrushIndex);
  let canDeleteSelectedTileMask = savedTileMasks.length > 1;
  let handleDeleteSelectedBrush = () => {
    if (selectedSavedBrushIndex !== undefined) {
      return setSavedBrushes(prev => Belt_Array.keepWithIndex(prev, (param, idx) => idx !== selectedSavedBrushIndex));
    }
    
  };
  let handleDeleteSelectedTileMask = () => {
    if (canDeleteSelectedTileMask) {
      return setSavedTileMasks(prev => {
        let next = Belt_Array.keepWithIndex(prev, (param, idx) => idx !== selectedTileMaskIndex);
        let nextLength = next.length;
        let nextIndex = nextLength === 0 ? 0 : (
            selectedTileMaskIndex >= nextLength ? nextLength - 1 | 0 : selectedTileMaskIndex
          );
        setSelectedTileMaskIndex(param => nextIndex);
        let mask = next[nextIndex];
        if (mask !== undefined) {
          setTileMask(param => mask);
        }
        return next;
      });
    }
    
  };
  let canDeleteCanvas = canvasCount > 1;
  let handleAddCanvas = () => {
    let newBoard = Array2D.make(boardDimI, boardDimJ, () => null);
    let newPan = computeCenteredPan(boardDimI, boardDimJ, 1);
    let newCanvas = makeCanvas(newBoard, 1, newPan);
    setCanvases(prev => prev.concat([newCanvas]));
    setSelectedCanvasId(param => newCanvas.id);
    clearHoverRef.current();
    setCursorOverlayOff(param => true);
    lastAutoCenteredDimsRef.current = [
      boardDimI,
      boardDimJ
    ];
  };
  let handleDeleteCanvas = () => {
    if (!canDeleteCanvas) {
      return;
    }
    let currentIndex = Belt_Array.getIndexBy(canvases, canvas => canvas.id === currentCanvasId);
    let nextSelectionId;
    if (currentIndex !== undefined) {
      let nextCanvas = canvases[currentIndex + 1 | 0];
      if (nextCanvas !== undefined) {
        nextSelectionId = nextCanvas.id;
      } else if (currentIndex > 0) {
        let prevCanvas = canvases[currentIndex - 1 | 0];
        nextSelectionId = prevCanvas !== undefined ? prevCanvas.id : undefined;
      } else {
        nextSelectionId = undefined;
      }
    } else {
      nextSelectionId = Stdlib_Option.flatMap(canvases[0], canvas => {
        if (canvas.id === currentCanvasId) {
          return;
        } else {
          return canvas.id;
        }
      });
    }
    setCanvases(prev => Belt_Array.keep(prev, canvas => canvas.id !== currentCanvasId));
    if (nextSelectionId !== undefined) {
      setSelectedCanvasId(param => nextSelectionId);
    }
    clearHoverRef.current();
    setCursorOverlayOff(param => true);
  };
  let handleSelectCanvas = canvasId => {
    if (canvasId !== selectedCanvasId) {
      setSelectedCanvasId(param => canvasId);
    }
    clearHoverRef.current();
    setCursorOverlayOff(param => true);
  };
  let onMouseMove = param => setCursorOverlayOff(param => false);
  let canApply = (boardI, boardJ, clickI, clickJ) => {
    let brushPosI = (boardI - clickI | 0) + brushCenterDimI | 0;
    let brushPosJ = (boardJ - clickJ | 0) + brushCenterDimJ | 0;
    let brushAllows = Stdlib_Option.getOr(Array2D.check(brush, brushPosI, brushPosJ), false);
    let maskAllows = Stdlib_Option.getOr(Array2D.check(tileMask, Primitive_int.mod_(boardI, tileMaskDimI), Primitive_int.mod_(boardJ, tileMaskDimJ)), false);
    if (brushAllows) {
      return maskAllows;
    } else {
      return false;
    }
  };
  let getBrushColor = () => {
    if (brushMode === "Color") {
      return myColor;
    } else {
      return null;
    }
  };
  let applyBrush = (clickI, clickJ) => setBoard(b => b.map((row, boardI) => row.map((cell, boardJ) => {
    if (canApply(boardI, boardJ, clickI, clickJ)) {
      return getBrushColor();
    } else {
      return cell;
    }
  })));
  React.useEffect(() => {
    window.addEventListener("mousemove", onMouseMove);
    return () => {
      window.removeEventListener("mousemove", onMouseMove);
    };
  }, []);
  React.useEffect(() => {
    let handleKeyDown = event => {
      if (event.metaKey) {
        let match = event.key;
        switch (match) {
          case "[" :
            event.preventDefault();
            let factor = 1 / Initials.zoom_factor;
            return updateZoom(prev => prev * factor);
          case "]" :
            event.preventDefault();
            return updateZoom(prev => prev * Initials.zoom_factor);
          default:
            return;
        }
      } else {
        let match$1 = event.key;
        switch (match$1) {
          case "ArrowDown" :
            event.preventDefault();
            return adjustPan(0, 20);
          case "ArrowLeft" :
            event.preventDefault();
            return adjustPan(- 20, 0);
          case "ArrowRight" :
            event.preventDefault();
            return adjustPan(20, 0);
          case "ArrowUp" :
            event.preventDefault();
            return adjustPan(0, - 20);
          default:
            return;
        }
      }
    };
    window.addEventListener("keydown", handleKeyDown);
    return () => {
      window.removeEventListener("keydown", handleKeyDown);
    };
  }, []);
  let offsetXString = pan[0].toString();
  let offsetYString = pan[1].toString();
  let zoomString = zoom.toString();
  let transformValue = "translate3d(" + offsetXString + "px, " + offsetYString + "px, 0) scale(" + zoomString + ")";
  return JsxRuntime.jsxs("div", {
    children: [
      JsxRuntime.jsxs("div", {
        children: [
          JsxRuntime.jsx(SavedBrushesPanel.make, {
            board: board,
            brush: brush,
            setBrush: match$3[1],
            savedBrushes: savedBrushes,
            setSavedBrushes: setSavedBrushes,
            canDeleteSelectedBrush: canDeleteSelectedBrush,
            handleDeleteSelectedBrush: handleDeleteSelectedBrush
          }),
          JsxRuntime.jsx(SavedTileMasksPanel.make, {
            board: board,
            setTileMask: setTileMask,
            savedTileMasks: savedTileMasks,
            setSavedTileMasks: setSavedTileMasks,
            selectedTileMaskIndex: selectedTileMaskIndex,
            setSelectedTileMaskIndex: setSelectedTileMaskIndex,
            canDeleteSelectedTileMask: canDeleteSelectedTileMask,
            handleDeleteSelectedTileMask: handleDeleteSelectedTileMask
          })
        ],
        className: "flex flex-row gap-2 h-full flex-none p-2"
      }),
      JsxRuntime.jsxs("div", {
        children: [
          JsxRuntime.jsx("div", {
            children: JsxRuntime.jsx(CanvasViewport.make, {
              canvasContainerRef: canvasContainerRef,
              board: board,
              boardDimI: boardDimI,
              boardDimJ: boardDimJ,
              transformValue: transformValue,
              zoom: zoom,
              pan: pan,
              cursorOverlayOff: match$13[0],
              setCursorOverlayOff: setCursorOverlayOff,
              isMouseDown: isMouseDown,
              applyBrush: applyBrush,
              showCursorOverlay: showCursorOverlay,
              canvasBackgroundColor: canvasBackgroundColor,
              viewportBackgroundColor: viewportBackgroundColor,
              isSilhouette: isSilhouette,
              clearHoverRef: clearHoverRef,
              brush: brush,
              brushDimI: brushDimI,
              brushDimJ: brushDimJ,
              brushCenterDimI: brushCenterDimI,
              brushCenterDimJ: brushCenterDimJ,
              tileMask: tileMask,
              tileMaskDimI: tileMaskDimI,
              tileMaskDimJ: tileMaskDimJ
            }),
            className: "flex-1 pt-2"
          }),
          JsxRuntime.jsx(CanvasThumbnails.make, {
            canvases: canvases,
            currentCanvasId: currentCanvasId,
            canDeleteCanvas: canDeleteCanvas,
            handleDeleteCanvas: handleDeleteCanvas,
            handleAddCanvas: handleAddCanvas,
            onSelectCanvas: handleSelectCanvas
          })
        ],
        className: "flex flex-col flex-1 overflow-x-hidden"
      }),
      JsxRuntime.jsx(ControlsPanel.make, {
        brushMode: brushMode,
        setBrushMode: match[1],
        myColor: myColor,
        setMyColor: match$9[1],
        canvasBackgroundColor: canvasBackgroundColor,
        setCanvasBackgroundColor: match$10[1],
        viewportBackgroundColor: viewportBackgroundColor,
        setViewportBackgroundColor: match$11[1],
        isSilhouette: isSilhouette,
        setIsSilhouette: match$12[1],
        showCursorOverlay: showCursorOverlay,
        setShowCursorOverlay: match$8[1],
        resizeMode: resizeMode,
        setResizeMode: match$16[1],
        resizeRowsInput: resizeRowsInput,
        setResizeRowsInput: setResizeRowsInput,
        resizeColsInput: resizeColsInput,
        setResizeColsInput: setResizeColsInput,
        canSubmitResize: canSubmitResize,
        onSubmitResize: handleResizeSubmit,
        zoom: zoom,
        onZoomIn: zoomIn,
        onZoomOut: zoomOut,
        onZoomReset: resetZoom,
        onCenterCanvas: centerCanvas,
        onFitCanvas: fitCanvasToViewport,
        exportScaleInput: exportScaleInput,
        setExportScaleInput: match$14[1],
        includeExportBackground: includeExportBackground,
        setIncludeExportBackground: match$15[1],
        canExport: canExport,
        onExport: handleExportPng
      })
    ],
    className: " flex flex-row h-dvh overflow-x-hidden"
  });
}

let make = App;

export {
  make,
}
/* defaultBrushes Not a pure module */
