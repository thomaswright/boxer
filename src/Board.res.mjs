// Generated by ReScript, PLEASE EDIT WITH CARE

import * as Stdlib_Option from "rescript/lib/es6/Stdlib_Option.js";
import * as BoardColorJs from "./BoardColor.js";
import * as Primitive_option from "rescript/lib/es6/Primitive_option.js";

function colorToUint32(prim) {
  return BoardColorJs.hexToUint32(prim);
}

function uint32ToHex(prim) {
  return BoardColorJs.uint32ToHex(prim);
}

function make(rows, cols) {
  let clampedRows = rows < 0 ? 0 : rows;
  let clampedCols = cols < 0 ? 0 : cols;
  return {
    rows: clampedRows,
    cols: clampedCols,
    data: new Uint32Array(clampedRows * clampedCols | 0)
  };
}

function dims(board) {
  return [
    board.rows,
    board.cols
  ];
}

function index(board, row, col) {
  return (row * board.cols | 0) + col | 0;
}

function inBounds(board, row, col) {
  if (row >= 0 && row < board.rows && col >= 0) {
    return col < board.cols;
  } else {
    return false;
  }
}

function getValue(board, row, col) {
  if (inBounds(board, row, col)) {
    return Stdlib_Option.getOr(board.data[index(board, row, col)], 0);
  } else {
    return 0;
  }
}

function valueToNullable(value) {
  if (value === 0) {
    return null;
  } else {
    return BoardColorJs.uint32ToHex(value);
  }
}

function get(board, row, col) {
  return valueToNullable(getValue(board, row, col));
}

function nullableToValue(color) {
  if (!(color == null)) {
    return BoardColorJs.hexToUint32(color);
  } else {
    return 0;
  }
}

function copyData(board) {
  return board.data.slice();
}

function set(board, row, col, color) {
  if (!inBounds(board, row, col)) {
    return board;
  }
  let idx = index(board, row, col);
  let nextValue = nullableToValue(color);
  let currentValue = Stdlib_Option.getOr(board.data[idx], 0);
  if (currentValue === nextValue) {
    return board;
  }
  let nextData = board.data.slice();
  nextData[idx] = nextValue;
  return {
    rows: board.rows,
    cols: board.cols,
    data: nextData
  };
}

function clone(board) {
  return {
    rows: board.rows,
    cols: board.cols,
    data: board.data.slice()
  };
}

function unsafeSetInPlace(board, row, col, value) {
  if (inBounds(board, row, col)) {
    board.data[index(board, row, col)] = value;
    return;
  }
  
}

function setInPlace(board, row, col, color) {
  unsafeSetInPlace(board, row, col, nullableToValue(color));
}

let setValueInPlace = unsafeSetInPlace;

function setMany(board, updates) {
  let copyRef = {
    contents: undefined
  };
  let ensureCopy = () => {
    let data = copyRef.contents;
    if (data !== undefined) {
      return data;
    }
    let copied = board.data.slice();
    copyRef.contents = copied;
    return copied;
  };
  updates.forEach(param => {
    let col = param[1];
    let row = param[0];
    if (!inBounds(board, row, col)) {
      return;
    }
    let idx = index(board, row, col);
    let nextValue = nullableToValue(param[2]);
    let currentValue = Stdlib_Option.getOr(board.data[idx], 0);
    if (currentValue === nextValue) {
      return;
    }
    let data = ensureCopy();
    data[idx] = nextValue;
  });
  let data = copyRef.contents;
  if (data !== undefined) {
    return {
      rows: board.rows,
      cols: board.cols,
      data: data
    };
  } else {
    return board;
  }
}

function toBoolGrid(board) {
  let match = dims(board);
  let cols = match[1];
  let result = [];
  for (let row = 0, row_finish = match[0]; row < row_finish; ++row) {
    let rowArray = [];
    for (let col = 0; col < cols; ++col) {
      let hasColor = getValue(board, row, col) !== 0;
      rowArray.push(hasColor);
    }
    result.push(rowArray);
  }
  return result;
}

function forEachValue(board, f) {
  let match = dims(board);
  let cols = match[1];
  for (let row = 0, row_finish = match[0]; row < row_finish; ++row) {
    for (let col = 0; col < cols; ++col) {
      let value = getValue(board, row, col);
      f(row, col, value);
    }
  }
}

function fromArray2D(array2d) {
  let rows = array2d.length;
  let cols = Stdlib_Option.mapOr(array2d[0], 0, firstRow => firstRow.length);
  let board = make(rows, cols);
  for (let row = 0; row < rows; ++row) {
    let rowArray = array2d[row];
    if (rowArray !== undefined) {
      for (let col = 0; col < cols; ++col) {
        let color = rowArray[col];
        if (color !== undefined) {
          unsafeSetInPlace(board, row, col, nullableToValue(Primitive_option.valFromOption(color)));
        }
        
      }
    }
    
  }
  return board;
}

function toArray2D(board) {
  let match = dims(board);
  let cols = match[1];
  let result = [];
  for (let row = 0, row_finish = match[0]; row < row_finish; ++row) {
    let rowArray = [];
    for (let col = 0; col < cols; ++col) {
      rowArray.push(get(board, row, col));
    }
    result.push(rowArray);
  }
  return result;
}

function fill(rows, cols, color) {
  let board = make(rows, cols);
  let value = nullableToValue(color);
  if (value !== 0) {
    board.data.fill(value);
  }
  return board;
}

function mapValues(board, mapper) {
  let match = dims(board);
  let cols = match[1];
  let rows = match[0];
  let next = make(rows, cols);
  for (let row = 0; row < rows; ++row) {
    for (let col = 0; col < cols; ++col) {
      let value = mapper(row, col, get(board, row, col));
      unsafeSetInPlace(next, row, col, nullableToValue(value));
    }
  }
  return next;
}

let $$Uint32Array$1;

let $$TypedArray;

export {
  $$Uint32Array$1 as $$Uint32Array,
  $$TypedArray,
  colorToUint32,
  uint32ToHex,
  make,
  dims,
  index,
  inBounds,
  getValue,
  valueToNullable,
  get,
  nullableToValue,
  copyData,
  set,
  clone,
  unsafeSetInPlace,
  setInPlace,
  setValueInPlace,
  setMany,
  toBoolGrid,
  forEachValue,
  fromArray2D,
  toArray2D,
  fill,
  mapValues,
}
/* ./BoardColor.js Not a pure module */
